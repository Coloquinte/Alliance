.\\" auto-generated by docbook2man-spec $Revision: 1.2 $
.TH "DPGEN_NAND2MASK" "3" "17 June 2002" "ASIM/LIP6" "Alliance - genlib User's Manual"
.SH NAME
DPGEN_NAND2MASK \- Programmable Mask Macro-Generator
.SH SYNOPSIS
\fB#include <genlib.h>
.sp
void GENLIB_MACRO(
.nf
.ta 7n +20n
	DPGEN_NAND2MASK,
	char *\fImodelname\fB,
	long \fIflags\fB,
	long \fIN\fB,
	char *\fIconstVal\fB
);
.fi
\fR.SH "DESCRIPTION"
.PP
Generate a \fIN\fR bits conditionnal NAND mask named \fImodelname\fR.
.PP
How it works :
.TP 0.2i
\(bu
if the cmd signal is set to '0', the mask is NOT
applied, so the whole operator behave like an inverter. 
.TP 0.2i
\(bu
if the cmd signal is set to '1', the mask IS
applied, the output is the \fBcomplemented\fR
result of the input value \fBANDed\fR with the mask
(suplied by \fIconstVal\fR).
.PP
.PP
The constant \fIconstVal\fR is given to the macro-generator
call, therefore the value cannot be changed afterward : it's
hard wired in the operator.
.PP
A common error is to give a real C constant for the
\fIconstVal\fR argument. Be aware that it is a character string.
.SS "TERMINAL NAMES"
.IP 1. 
cmd : mask control (1 bit). 
.IP 2. 
i0 : input (\fIN\fR bits). 
.IP 3. 
q : output (\fIN\fR bits). 
.IP 4. 
vdd : power. 
.IP 5. 
vss : ground. 
.SS "BEHAVIOR"
.sp
.nf
nq <= WITH cmd SELECT not(i0)                 WHEN '0',
                      not(i0 and X"0000FFFF") WHEN '1';
   
.sp
.fi
.SH "EXAMPLE"
.PP
.sp
.nf
GENLIB_MACRO(DPGEN_NAND2MASK, "model_nand2mask_0000FFFF_32"
                            , F_BEHAV|F_PLACE
                            , 32
                            , "0x0000FFFF" /* A string! */
                            );

GENLIB_LOINS( "model_nand2mask_0000FFFF_32"
            , "instance1_nand2mask_32"
            , "cmd"
            , "i0[31:0]"
            ,  "q[31:0]"
            , "vdd", "vss", NULL
            );
    
.sp
.fi
.SH "SEE ALSO"
.PP
\fBGENLIB_MACRO\fR(3),
\fBgenlib\fR(1)
