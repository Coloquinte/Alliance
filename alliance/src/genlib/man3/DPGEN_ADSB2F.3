.\\" auto-generated by docbook2man-spec $Revision: 1.1 $
.TH "DPGEN_ADSB2F" "3" "24 May 2002" "ASIM/LIP6" "Alliance - genlib User's Manual"
.SH NAME
DPGEN_ADSB2F \- Adder/Substractor Macro-Generator
.SH SYNOPSIS
\fB#include <genlib.h>
.sp
void GENLIB_MACRO(
.nf
.ta 7n +20n
	DPGEN_ADSB2F,
	char *\fImodelname\fB,
	long \fIflags\fB,
	long \fIN\fB
);
.fi
\fR.SH "DESCRIPTION"
.PP
Generate a \fIN\fR bits adder/substractor named \fImodelname\fR.
.PP
How it works :
.TP 0.2i
\(bu
if the add_sub signal is set to '0' an addition is
performed, otherwise it's a substraction.
.TP 0.2i
\(bu
Operation can be either signed or unsigned. In unsigned
mode c32 is the overflow, in unsigned mode you have to compute
overflow by \fBXORing\fR c32 and c31.
.PP
.SS "TERMINAL NAMES"
.IP 1. 
add_sub : select addition or substraction
(input, 1 bit).
.IP 2. 
c32 : carry out. In unsigned mode, this is the
overflow (output, 1 bits). 
.IP 3. 
c31 : used to compute overflow in signed mode :
overflow := c32 xor c31 (output, 1 bits).
.IP 4. 
i1 : first operand (input, \fIN\fR bits). 
.IP 5. 
i0 : second operand (input, \fIN\fR bits). 
.IP 6. 
q : output (\fIN\fR bits). 
.IP 7. 
vdd : power. 
.IP 8. 
vss : ground. 
.SH "EXAMPLE"
.PP
.sp
.nf
GENLIB_MACRO(DPGEN_ADSB2F, "model_adsb2f_32"
                            , F_BEHAV|F_PLACE
                            , 32
                            );

GENLIB_LOINS( "model_adsb2f_32"
            , "instance1_adsb2f_32"
            , "add_sub"
            , "c32"
            , "c31"
            , "i1[31:0]"
            , "i0[31:0]"
            ,  "q[31:0]"
            , "vdd", "vss", NULL
            );
    
.sp
.fi
.SH "SEE ALSO"
.PP
\fBGENLIB_MACRO\fR(3),
\fBgenlib\fR(1)
