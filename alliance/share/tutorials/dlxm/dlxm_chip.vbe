
-- ###----------------------------------------------------------------###
-- #									#
-- # file	: dlxm_chip.vbe						#
-- # date	: February  5 1995		       			#
-- # version	: v0.3							#
-- #									#
-- # origin	: this description has been developed by CAO-VLSI team	#
-- #		  at MASI laboratory, University Pierre et Marie Curie	#
-- #		  URA CNRS 818, Institut Blaise Pascal			#
-- #		  4 Place Jussieu 75252 Paris Cedex 05 - France		#
-- # E-mail      :      cao-vlsi@masi.ibp.fr                            #
-- #									#
-- # descr.	: VHDL description of the DLX's processor (micro-      	#
-- #		  programmed implementation)				#
-- ###----------------------------------------------------------------###

entity DLXM_CHIP is

  port (
       CK      : in    bit                         ;
       RESET   : in    bit                         ;
       FRZ     : in    bit                         ;
       IT      : in    bit_vector ( 3 downto 0)    ;
       DATA    : inout mux_vector (31 downto 0) bus;
       BYTE    : out   bit_vector ( 0     to 3)    ;
       RW      : out   bit                         ;
       ADR     : out   mux_vector(31 downto 0)  bus;
       SCIN    : in    bit                         ;
       TEST    : in    bit                         ;
       SCOUT   : out   bit                         ;
       VDD     : in    bit                         ;
       VSS     : in    bit                         ;
       VDDP    : in    bit                         ;
       VSSP    : in    bit
       ) ;

end DLXM_CHIP ;





architecture BEHAVIOURAL of DLXM_CHIP is

signal CKFRZ_S   : bit                              ;	-- internal clock
signal CK_S      : bit                              ;	-- internal clock
signal CKDLY0_S  : bit                              ;	-- internal clock
signal CKDLY1_S  : bit                              ;	-- internal clock
signal CKDLY2_S  : bit                              ;	-- internal clock
signal CKDLY3_S  : bit                              ;	-- internal clock
signal CKDLY4_S  : bit                              ;	-- internal clock
signal CKDLY5_S  : bit                              ;	-- internal clock
signal CKDLY6_S  : bit                              ;	-- internal clock

signal SHRTBCH_S : bit_vector ( 6 downto 0)         ;
signal LONGBCH_S : bit_vector ( 6 downto 0)         ;
signal STRTADR_S : bit_vector ( 6 downto 0)         ;
signal BCHNUL_S  : bit_vector ( 6 downto 0)         ;
signal BCHOP4_S  : bit_vector ( 6 downto 0)         ;
signal BCHOP16_S : bit_vector ( 6 downto 0)         ;
signal BCHIN8_S  : bit_vector ( 6 downto 0)         ;

signal MICADR_S  : bit_vector ( 6 downto 0)         ;	-- next micro ins. adr.
signal MICADR_R  : reg_vector ( 6 downto 0) register;	-- micro ins. adr reg.
signal MICINS_S  : bit_vector (26 downto 0)         ;	-- next  micro ins.
signal RESTMI_X  : bit_vector (26 downto 0)         ;	-- reset micro ins.
signal MICINS_R  : reg_vector (26 downto 0) register;	-- micro ins. reg.

signal CTLEXC_S  : bit                              ;	-- operand x  field
signal CTLOPX_S  : bit_vector ( 3 downto 0)         ;	-- operand x  field
signal CTLOPY_S  : bit_vector ( 2 downto 0)         ;	-- operand y  field
signal CTLALU_S  : bit_vector ( 3 downto 0)         ;	-- alu        field
signal CTLRES_S  : bit_vector ( 3 downto 0)         ;	-- result     field
signal CTLMEM_S  : bit_vector ( 3 downto 0)         ;	-- read/write field
signal CTLSEQ_S  : bit_vector ( 2 downto 0)         ;	-- sequencer  field
signal CTLDAT_S  : bit_vector ( 3 downto 0)         ;	-- constante  field

signal REDPNT_S  : bit_vector ( 4 downto 0)         ;	-- read pointer
signal WRTPNT_S  : bit_vector ( 4 downto 0)         ;	-- write pointer
signal REDREG_S  : bit_vector (31 downto 0)         ;	-- value read from reg.
signal IFORMT_S  : bit                              ;	-- i format instr.

signal IR_R      : reg_vector (31 downto 0) register;	-- instruction reg.
signal OPCOD_S   : bit_vector ( 5 downto 0)         ;	-- oper. code

signal R1_R      : reg_vector (31 downto 0) register;	-- integer reg #1
signal R2_R      : reg_vector (31 downto 0) register;	-- integer reg #2
signal R3_R      : reg_vector (31 downto 0) register;	-- integer reg #3
signal R4_R      : reg_vector (31 downto 0) register;	-- integer reg #4
signal R5_R      : reg_vector (31 downto 0) register;	-- integer reg #5
signal R6_R      : reg_vector (31 downto 0) register;	-- integer reg #6
signal R7_R      : reg_vector (31 downto 0) register;	-- integer reg #7
signal R8_R      : reg_vector (31 downto 0) register;	-- integer reg #8
signal R9_R      : reg_vector (31 downto 0) register;	-- integer reg #9
signal R10_R     : reg_vector (31 downto 0) register;	-- integer reg #10
signal R11_R     : reg_vector (31 downto 0) register;	-- integer reg #11
signal R12_R     : reg_vector (31 downto 0) register;	-- integer reg #12
signal R13_R     : reg_vector (31 downto 0) register;	-- integer reg #13
signal R14_R     : reg_vector (31 downto 0) register;	-- integer reg #14
signal R15_R     : reg_vector (31 downto 0) register;	-- integer reg #15
signal R16_R     : reg_vector (31 downto 0) register;	-- integer reg #16
signal R17_R     : reg_vector (31 downto 0) register;	-- integer reg #17
signal R18_R     : reg_vector (31 downto 0) register;	-- integer reg #18
signal R19_R     : reg_vector (31 downto 0) register;	-- integer reg #19
signal R20_R     : reg_vector (31 downto 0) register;	-- integer reg #20
signal R21_R     : reg_vector (31 downto 0) register;	-- integer reg #21
signal R22_R     : reg_vector (31 downto 0) register;	-- integer reg #22
signal R23_R     : reg_vector (31 downto 0) register;	-- integer reg #23
signal R24_R     : reg_vector (31 downto 0) register;	-- integer reg #24
signal R25_R     : reg_vector (31 downto 0) register;	-- integer reg #25
signal R26_R     : reg_vector (31 downto 0) register;	-- integer reg #26
signal R27_R     : reg_vector (31 downto 0) register;	-- integer reg #27
signal R28_R     : reg_vector (31 downto 0) register;	-- integer reg #28
signal R29_R     : reg_vector (31 downto 0) register;	-- integer reg #29
signal R30_R     : reg_vector (31 downto 0) register;	-- integer reg #30
signal R31_R     : reg_vector (31 downto 0) register;	-- integer reg #31

signal PC_R      : reg_vector (31 downto 0) register;	-- progr. counter
signal AD_R      : reg_vector (31 downto 0) register;	-- address register
signal IAR_R     : reg_vector (31 downto 0) register;	-- intr. adr. reg.
signal SR_R      : reg_vector (31 downto 0) register;	-- status register
signal TVR_R     : reg_vector (31 downto 0) register;	-- trap vector reg.
signal DT_R      : reg_vector (31 downto 0) register;	-- data register

signal OPERY_S   : bit_vector (31 downto 0)         ;	-- y operand
signal OPERX_S   : bit_vector (31 downto 0)         ;	-- x operand

signal ADDY_S    : bit_vector (31 downto 0)         ;	-- adder's y operand
signal ADDX_S    : bit_vector (31 downto 0)         ;	-- adder's x operand
signal ADDRES_S  : bit_vector (31 downto 0)         ;	-- adder's result
signal ADDCRY_S  : bit_vector (32 downto 0)         ;	-- adder's carry
signal ADDOVR_S  : bit                              ;	-- adder's overflow

signal SEQ_S     : bit                              ;	-- x  = y arith.
signal SNE_S     : bit                              ;	-- x /= y arith.
signal SGE_S     : bit                              ;	-- x >= y arith.
signal SGT_S     : bit                              ;	-- x  > y arith.
signal SLE_S     : bit                              ;	-- x <= y arith.
signal SLT_S     : bit                              ;	-- x  < y arith.

signal SHIN_S    : bit_vector (31 downto 0)         ;	-- shift right in
signal SHRIT_S   : bit_vector (31 downto 0)         ;	-- shift result (right)
signal SHLFT_S   : bit_vector (31 downto 0)         ;	-- shift result (left)

signal RESULT_S  : bit_vector (31 downto 0)         ;	-- alu's result
signal RESNUL_S  : bit                              ;	-- alu's result = 0

signal IMD16_S   : bit_vector (31 downto 0)         ;	-- signed 16 bit imd
signal IMD18_S   : bit_vector (31 downto 0)         ;	-- short branch offset
signal IMD28_S   : bit_vector (31 downto 0)         ;	-- long  branch offset

signal WORD_S    : bit                              ;
signal BYTE_S    : bit                              ;
signal BYTSEL_S  : bit_vector ( 0     to 3)         ;

signal REDDAT_S  : bit_vector (31 downto 0)         ;	-- aligned data
signal NEWSR_X   : bit_vector (15 downto 0)         ;	-- new status

signal WENSR_S   : bit                              ;	-- status reg. wen.
signal WENIAR_S  : bit                              ;	-- it. adr. reg. wen.
signal WENTVR_S  : bit                              ;	-- trap vec. reg. wen.
signal WENPC_S   : bit                              ;	-- progr. counter wen.
signal WENAD_S   : bit                              ;	-- address reg. wen.
signal WENREG_S  : bit                              ;	-- integer reg. wen.
signal WENDT_S   : bit                              ;	-- data reg. wen.
signal WENIR_S   : bit                              ;	-- ins. reg. wen.

signal INTRQS_X  : bit                              ;	-- interrupt request
signal EXCRQS_X  : bit                              ;	-- exception request
signal RQS_X     : bit                              ;	-- request

signal PRVINS_X  : bit                              ;	-- privileged instr.
signal ILLINS_X  : bit                              ;	-- illegal instruction
signal OPVIOL_X  : bit                              ;	-- ins. violation
signal OVRFLO_X  : bit                              ;	-- overflow
signal DAALGN_X  : bit                              ;	-- data adr. algn.
signal DASGMT_X  : bit                              ;	-- data adr. segment
signal IAALGN_X  : bit                              ;	-- ins. adr. algn.
signal IASGMT_X  : bit                              ;	-- ins. adr. segment

signal FRZ_R     : reg_bit                  register;	-- freeze
signal RESET_R   : reg_bit                  register;	-- reset register
signal CPURST_R  : reg_bit                  register;	-- CPU reseted
signal IAV_R     : reg_bit                  register;	-- ins. adr. viol.
signal DAV_R     : reg_bit                  register;	-- data adr. viol.
signal ICO_R     : reg_bit                  register;	-- opcode viol.
signal OVR_R     : reg_bit                  register;	-- overflow
signal IT_R      : reg_vector ( 3 downto 0) register;	-- external it

constant R0_R     : bit_vector (31 downto 0) :=X"00000000"; 	-- reg #0 = 0

constant add_i    : bit_vector (5 downto 0) := B"000_000"  ;	-- add
constant addu_i   : bit_vector (5 downto 0) := B"000_001"  ;	-- addu
constant sub_i    : bit_vector (5 downto 0) := B"000_010"  ;	-- sub
constant subu_i   : bit_vector (5 downto 0) := B"000_011"  ;	-- subu
constant addi_i   : bit_vector (5 downto 0) := B"000_100"  ;	-- addi
constant addui_i  : bit_vector (5 downto 0) := B"000_101"  ;	-- addui
constant subi_i   : bit_vector (5 downto 0) := B"000_110"  ;	-- subi
constant subui_i  : bit_vector (5 downto 0) := B"000_111"  ;	-- subui
constant sll_i    : bit_vector (5 downto 0) := B"001_000"  ;	-- sll
constant srl_i    : bit_vector (5 downto 0) := B"001_001"  ;	-- srl
constant sra_i    : bit_vector (5 downto 0) := B"001_010"  ;	-- sra
constant slli_i   : bit_vector (5 downto 0) := B"001_100"  ;	-- slli
constant srli_i   : bit_vector (5 downto 0) := B"001_101"  ;	-- srli
constant srai_i   : bit_vector (5 downto 0) := B"001_110"  ;	-- srai
constant lhi_i    : bit_vector (5 downto 0) := B"001_111"  ;	-- lhi
constant seq_i    : bit_vector (5 downto 0) := B"010_000"  ;	-- seq
constant sne_i    : bit_vector (5 downto 0) := B"010_001"  ;	-- sne
constant sge_i    : bit_vector (5 downto 0) := B"010_010"  ;	-- sge
constant sle_i    : bit_vector (5 downto 0) := B"010_011"  ;	-- sle
constant seqi_i   : bit_vector (5 downto 0) := B"010_100"  ;	-- seqi
constant snei_i   : bit_vector (5 downto 0) := B"010_101"  ;	-- snei
constant sgei_i   : bit_vector (5 downto 0) := B"010_110"  ;	-- sgei
constant slei_i   : bit_vector (5 downto 0) := B"010_111"  ;	-- slei
constant sgt_i    : bit_vector (5 downto 0) := B"011_010"  ;	-- sgt
constant slt_i    : bit_vector (5 downto 0) := B"011_011"  ;	-- slt
constant sgti_i   : bit_vector (5 downto 0) := B"011_110"  ;	-- sgti
constant slti_i   : bit_vector (5 downto 0) := B"011_111"  ;	-- slti
constant and_i    : bit_vector (5 downto 0) := B"100_000"  ;	-- and
constant or_i     : bit_vector (5 downto 0) := B"100_001"  ;	-- or
constant xor_i    : bit_vector (5 downto 0) := B"100_011"  ;	-- xor
constant andi_i   : bit_vector (5 downto 0) := B"100_100"  ;	-- andi
constant ori_i    : bit_vector (5 downto 0) := B"100_101"  ;	-- ori
constant xori_i   : bit_vector (5 downto 0) := B"100_111"  ;	-- xori

constant sw_i     : bit_vector (5 downto 0) := B"101_000"  ;	-- sw
constant sh_i     : bit_vector (5 downto 0) := B"101_001"  ;	-- sh
constant sb_i     : bit_vector (5 downto 0) := B"101_010"  ;	-- sb
constant lbu_i    : bit_vector (5 downto 0) := B"101_011"  ;	-- lbu
constant lw_i     : bit_vector (5 downto 0) := B"101_100"  ;	-- lw
constant lh_i     : bit_vector (5 downto 0) := B"101_101"  ;	-- lh
constant lb_i     : bit_vector (5 downto 0) := B"101_110"  ;	-- lb
constant lhu_i    : bit_vector (5 downto 0) := B"101_111"  ;	-- lhu

constant jr_i     : bit_vector (5 downto 0) := B"110_000"  ;	-- jr
constant jalr_i   : bit_vector (5 downto 0) := B"110_001"  ;	-- jalr
constant movs2i_i : bit_vector (5 downto 0) := B"110_010"  ;	-- movi2s
constant movi2s_i : bit_vector (5 downto 0) := B"110_011"  ;	-- movs2i
constant beqz_i   : bit_vector (5 downto 0) := B"110_100"  ;	-- beqz
constant bnez_i   : bit_vector (5 downto 0) := B"110_101"  ;	-- bnez
constant j_i      : bit_vector (5 downto 0) := B"111_000"  ;	-- j
constant jal_i    : bit_vector (5 downto 0) := B"111_001"  ;	-- jal
constant rfe_i    : bit_vector (5 downto 0) := B"111_010"  ;	-- rfe
constant trap_i   : bit_vector (5 downto 0) := B"111_011"  ;	-- trap

constant c0     : bit_vector (31 downto 0) := X"00000000";
constant c1     : bit_vector (31 downto 0) := X"00000001";
constant c4     : bit_vector (31 downto 0) := X"00000004";
constant c16    : bit_vector (31 downto 0) := X"00000010";
constant cb     : bit_vector (31 downto 0) := X"000000ff";
constant ch     : bit_vector (31 downto 0) := X"0000ffff";

constant e_no   : bit                     := '0' ;
constant e_il   : bit                     := '1' ;

constant x_rs   : bit_vector (3 downto 0) := B"0000" ;
constant x_rt   : bit_vector (3 downto 0) := B"0001" ;
constant x_pc   : bit_vector (3 downto 0) := B"0100" ;
constant x_ad   : bit_vector (3 downto 0) := B"0101" ;
constant x_sr   : bit_vector (3 downto 0) := B"0110" ;
constant x_tv   : bit_vector (3 downto 0) := B"0010" ;
constant x_ia   : bit_vector (3 downto 0) := B"0111" ;
constant x_c0   : bit_vector (3 downto 0) := B"1000" ;
constant x_cb   : bit_vector (3 downto 0) := B"1100" ;
constant x_ch   : bit_vector (3 downto 0) := B"1111" ;

constant y_i16  : bit_vector (2 downto 0) := B"000" ;
constant y_i18  : bit_vector (2 downto 0) := B"001" ;
constant y_i28  : bit_vector (2 downto 0) := B"010" ;
constant y_dt   : bit_vector (2 downto 0) := B"011" ;
constant y_ad   : bit_vector (2 downto 0) := B"100" ;
constant y_c0   : bit_vector (2 downto 0) := B"101" ;
constant y_c4   : bit_vector (2 downto 0) := B"110" ;
constant y_c16  : bit_vector (2 downto 0) := B"111" ;

constant a_sum  : bit_vector (3 downto 0) := B"0000" ;
constant a_smv  : bit_vector (3 downto 0) := B"0001" ;
constant a_dif  : bit_vector (3 downto 0) := B"0010" ;
constant a_dfv  : bit_vector (3 downto 0) := B"0011" ;
constant a_and  : bit_vector (3 downto 0) := B"0100" ;
constant a_or   : bit_vector (3 downto 0) := B"0101" ;
constant a_xor  : bit_vector (3 downto 0) := B"0110" ;
constant a_sll  : bit_vector (3 downto 0) := B"0111" ;
constant a_srl  : bit_vector (3 downto 0) := B"1000" ;
constant a_sra  : bit_vector (3 downto 0) := B"1001" ;
constant a_seq  : bit_vector (3 downto 0) := B"1010" ;
constant a_sne  : bit_vector (3 downto 0) := B"1011" ;
constant a_sge  : bit_vector (3 downto 0) := B"1100" ;
constant a_sgt  : bit_vector (3 downto 0) := B"1101" ;
constant a_sle  : bit_vector (3 downto 0) := B"1110" ;
constant a_slt  : bit_vector (3 downto 0) := B"1111" ;

constant r_no   : bit_vector (3 downto 0) := B"0000" ;
constant r_pc   : bit_vector (3 downto 0) := B"0001" ;
constant r_ad   : bit_vector (3 downto 0) := B"0010" ;
constant r_rd   : bit_vector (3 downto 0) := B"0100" ;
constant r_31   : bit_vector (3 downto 0) := B"0101" ;
constant r_ia   : bit_vector (3 downto 0) := B"1000" ;
constant r_si   : bit_vector (3 downto 0) := B"1001" ;
constant r_tv   : bit_vector (3 downto 0) := B"1010" ;
constant r_sr   : bit_vector (3 downto 0) := B"1100" ;
constant r_ss   : bit_vector (3 downto 0) := B"1101" ;

constant m_no   : bit_vector (3 downto 0) := B"0011" ;
constant m_fch  : bit_vector (3 downto 0) := B"1010" ;
constant m_rw   : bit_vector (3 downto 0) := B"0010" ;
constant m_ww   : bit_vector (3 downto 0) := B"0000" ;
constant m_rb   : bit_vector (3 downto 0) := B"0110" ;
constant m_wb   : bit_vector (3 downto 0) := B"0100" ;

constant s_bo16 : bit_vector (2 downto 0) := B"000" ;
constant s_bo4  : bit_vector (2 downto 0) := B"001" ;
constant s_bi8  : bit_vector (2 downto 0) := B"010" ;
constant s_sb   : bit_vector (2 downto 0) := B"011" ;
constant s_lb   : bit_vector (2 downto 0) := B"100" ;
constant s_nul  : bit_vector (2 downto 0) := B"101" ;
constant s_strt : bit_vector (2 downto 0) := B"110" ;

begin

	-- ###--------------------------------------------------------###
	-- #   checking power supplies					#
	-- ###--------------------------------------------------------###

power : assert ((VDD and VDDP) = '1' and (VSS or VSSP) = '0')
        report  "power supply missing on `dlx_m` processor"
        severity WARNING;

	-- ###--------------------------------------------------------###
	-- #   internal clocks						#
	-- ###--------------------------------------------------------###

CKFRZ_S  <= CK and not FRZ;
CK_S     <= CK            ;
CKDLY0_S <= CK            ;
CKDLY1_S <= CKDLY0_S      ;
CKDLY2_S <= CKDLY1_S      ;
CKDLY3_S <= CKDLY2_S      ;
CKDLY4_S <= CKDLY3_S      ;
CKDLY5_S <= CKDLY4_S      ;
CKDLY6_S <= CKDLY5_S      ;

	-- ###--------------------------------------------------------###
	-- #   hardware interrupt requests				#
	-- #     - interrupt request					#
	-- #     - exception request					#
	-- #     - global interrupt request signal			#
	-- ###--------------------------------------------------------###

INTRQS_X <= (IT_R (0) or IT_R (1) or IT_R (2) or IT_R (3)) and SR_R (1);

EXCRQS_X <= OVRFLO_X or             OVR_R or
            DAALGN_X or DASGMT_X or DAV_R or
            OPVIOL_X or ILLINS_X or ICO_R or
            IAALGN_X or IASGMT_X or IAV_R ;

RQS_X   <= INTRQS_X or EXCRQS_X or CPURST_R;

	-- ###--------------------------------------------------------###
	-- #   extract control fields from the micro-instruction	#
	-- # register							#
	-- ###--------------------------------------------------------###

CTLEXC_S <= MICINS_R (          26);
CTLOPX_S <= MICINS_R (25 downto 22);
CTLOPY_S <= MICINS_R (21 downto 19);
CTLALU_S <= MICINS_R (18 downto 15);
CTLRES_S <= MICINS_R (14 downto 11);
CTLMEM_S <= MICINS_R (10 downto  7);
CTLSEQ_S <= MICINS_R ( 6 downto  4);
CTLDAT_S <= MICINS_R ( 3 downto  0);

	-- ###--------------------------------------------------------###
	-- #   extract the operation code from the instruction		#
	-- ###--------------------------------------------------------###

OPCOD_S  <= IR_R (31 downto 26) ;

	-- ###--------------------------------------------------------###
	-- #   detect privileged instructions				#
	-- ###--------------------------------------------------------###

with OPCOD_S select
PRVINS_X <= '1' when rfe_i | movi2s_i | movs2i_i ,
            '0' when others                      ;

	-- ###--------------------------------------------------------###
	-- #   compute next micro-instruction's address			#
	-- ###--------------------------------------------------------###

SHRTBCH_S <= MICADR_R (6) & CTLDAT_S (3) & CTLDAT_S (2) &
             MICADR_R (3) & CTLDAT_S (1) & CTLDAT_S (0) & '0';

LONGBCH_S <= CTLDAT_S (3) & CTLDAT_S (2) & CTLDAT_S (1) &
             CTLDAT_S (0) & MICADR_R (2) & MICADR_R (1) & '0';

STRTADR_S <= '1'          & '1'          & CTLDAT_S (2) &
             CTLDAT_S (1) & CTLDAT_S (0) & RQS_X        & '0';

BCHNUL_S  <= MICADR_R (6) & RESNUL_S     & CTLDAT_S (2) &
             MICADR_R (3) & CTLDAT_S (1) & CTLDAT_S (0) & '0';

BCHOP4_S  <= MICADR_R (6) & MICADR_R (5) & MICADR_R (4) &
             MICADR_R (3) & OPCOD_S  (1) & OPCOD_S  (0) & '1';

BCHOP16_S <= OPCOD_S  (5) & OPCOD_S  (4) & OPCOD_S  (3) &
             OPCOD_S  (2) & '0'          & '0'          & '0';

BCHIN8_S  <= CTLDAT_S (2) & IR_R     (2) & IR_R     (1) &
             CTLDAT_S (1) & IR_R     (0) & CTLDAT_S (0) & '0';

with CTLSEQ_S select
MICADR_S <= SHRTBCH_S  when s_sb  ,
            LONGBCH_S  when s_lb  ,
            STRTADR_S  when s_strt,
            BCHNUL_S   when s_nul ,
            BCHOP4_S   when s_bo4 ,
            BCHOP16_S  when s_bo16,
            BCHIN8_S   when s_bi8 ,
            "000_0000" when others;

	-- ###--------------------------------------------------------###
	-- #   read the next micro-instruction from the control store	#
	-- ###--------------------------------------------------------###

with "0" & MICADR_S (6 downto 0) select
MICINS_S <=

  e_no & x_rt & y_c0  & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"00",-- rdrt
  e_no & x_rs & y_ad  & a_smv & r_rd & m_fch & s_strt & X"7" when X"01",-- add
  e_no & x_rs & y_ad  & a_dfv & r_rd & m_fch & s_strt & X"7" when X"05",-- sub
  e_no & x_rs & y_c0  & a_sum & r_ia & m_fch & s_strt & X"7" when X"06",-- i2ia

  e_no & x_c0 & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"08",-- rdsi
  e_no & x_rs & y_ad  & a_smv & r_rd & m_fch & s_strt & X"7" when X"09",-- add
  e_no & x_rs & y_ad  & a_dfv & r_rd & m_fch & s_strt & X"7" when X"0d",-- sub
  e_no & x_ia & y_c0  & a_sum & r_rd & m_fch & s_strt & X"7" when X"0e",-- ia2i

  e_no & x_rt & y_c0  & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"10",-- rdrt
  e_no & x_rs & y_ad  & a_sll & r_rd & m_fch & s_strt & X"7" when X"11",-- sll
  e_no & x_rs & y_c0  & a_sum & r_sr & m_fch & s_strt & X"7" when X"12",-- i2sr
  e_no & x_rs & y_ad  & a_srl & r_rd & m_fch & s_strt & X"7" when X"13",-- srl
  e_no & x_rs & y_ad  & a_sra & r_rd & m_fch & s_strt & X"7" when X"15",-- sra

  e_no & x_c0 & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"18",-- rdsi
  e_no & x_rs & y_ad  & a_sll & r_rd & m_fch & s_strt & X"7" when X"19",-- sll
  e_no & x_sr & y_c0  & a_sum & r_rd & m_fch & s_strt & X"7" when X"1a",-- sr2i
  e_no & x_rs & y_ad  & a_srl & r_rd & m_fch & s_strt & X"7" when X"1b",-- srl
  e_no & x_rs & y_ad  & a_sra & r_rd & m_fch & s_strt & X"7" when X"1d",-- sra
  e_no & x_ad & y_c16 & a_sll & r_rd & m_fch & s_strt & X"7" when X"1f",-- lhi

  e_no & x_rt & y_c0  & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"20",-- rdrt
  e_no & x_rs & y_ad  & a_seq & r_rd & m_fch & s_strt & X"7" when X"21",-- seq
  e_no & x_rs & y_c0  & a_sum & r_tv & m_fch & s_strt & X"7" when X"22",-- i2tv
  e_no & x_rs & y_ad  & a_sne & r_rd & m_fch & s_strt & X"7" when X"23",-- sne
  e_no & x_rs & y_ad  & a_sge & r_rd & m_fch & s_strt & X"7" when X"25",-- sge
  e_no & x_rs & y_ad  & a_sle & r_rd & m_fch & s_strt & X"7" when X"27",-- sle

  e_no & x_c0 & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"28",-- rdsi
  e_no & x_rs & y_ad  & a_seq & r_rd & m_fch & s_strt & X"7" when X"29",-- seq
  e_no & x_tv & y_c0  & a_sum & r_rd & m_fch & s_strt & X"7" when X"2a",-- tv2i
  e_no & x_rs & y_ad  & a_sne & r_rd & m_fch & s_strt & X"7" when X"2b",-- sne
  e_no & x_rs & y_ad  & a_sge & r_rd & m_fch & s_strt & X"7" when X"2d",-- sge
  e_no & x_rs & y_ad  & a_sle & r_rd & m_fch & s_strt & X"7" when X"2f",-- sle

  e_no & x_rt & y_c0  & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"30",-- rdrt
  e_no & x_rs & y_ad  & a_sgt & r_rd & m_fch & s_strt & X"7" when X"35",-- sgt
  e_no & x_rs & y_ad  & a_slt & r_rd & m_fch & s_strt & X"7" when X"37",-- slt

  e_no & x_c0 & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"38",-- rdsi
  e_no & x_rs & y_ad  & a_sgt & r_rd & m_fch & s_strt & X"7" when X"3d",-- sgt
  e_no & x_rs & y_ad  & a_slt & r_rd & m_fch & s_strt & X"7" when X"3f",-- slt

  e_no & x_rt & y_c0  & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"40",-- rdrt
  e_no & x_rs & y_ad  & a_and & r_rd & m_fch & s_strt & X"7" when X"41",-- and
  e_no & x_rs & y_ad  & a_or  & r_rd & m_fch & s_strt & X"7" when X"43",-- or
  e_no & x_c0 & y_c0  & a_sum & r_no & m_fch & s_strt & X"7" when X"44",-- ftch
  e_no & x_rs & y_ad  & a_xor & r_rd & m_fch & s_strt & X"7" when X"47",-- xor

  e_no & x_ch & y_i16 & a_and & r_ad & m_no  & s_bo4  & X"0" when X"48",-- rdui
  e_no & x_rs & y_ad  & a_and & r_rd & m_fch & s_strt & X"7" when X"49",-- and
  e_no & x_pc & y_i18 & a_sum & r_pc & m_no  & s_sb   & X"9" when X"4a",-- brch
  e_no & x_rs & y_ad  & a_or  & r_rd & m_fch & s_strt & X"7" when X"4b",-- or
  e_no & x_c0 & y_c0  & a_sum & r_no & m_fch & s_strt & X"7" when X"4c",-- ftch
  e_no & x_rs & y_ad  & a_xor & r_rd & m_fch & s_strt & X"7" when X"4f",-- xor

  e_no & x_rs & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"50",-- rssi
  e_no & x_rt & y_c0  & a_sum & r_no & m_ww  & s_sb   & X"2" when X"51",-- sw0
  e_no & x_rt & y_c0  & a_sum & r_no & m_wb  & s_sb   & X"2" when X"55",-- sb0
  e_no & x_cb & y_dt  & a_and & r_rd & m_fch & s_strt & X"7" when X"56",-- lbu1
  e_no & x_c0 & y_c0  & a_sum & r_no & m_rb  & s_sb   & X"7" when X"57",-- lbu0

  e_no & x_rs & y_i16 & a_sum & r_ad & m_no  & s_bo4  & X"0" when X"58",-- rssi
  e_no & x_c0 & y_c0  & a_sum & r_no & m_rw  & s_sb   & X"5" when X"59",-- lw0
  e_no & x_c0 & y_dt  & a_sum & r_rd & m_fch & s_strt & X"7" when X"5a",-- lw1
  e_no & x_c0 & y_c16 & a_dif & r_pc & m_no  & s_sb   & X"9" when X"5e",-- req2

  e_no & x_c0 & y_c0  & a_sum & r_no & m_no  & s_bo4  & X"0" when X"60",-- nop
  e_no & x_rs & y_c0  & a_sum & r_pc & m_no  & s_sb   & X"2" when X"61",-- jr0
  e_no & x_pc & y_c0  & a_sum & r_31 & m_no  & s_sb   & X"a" when X"63",-- jlr0
  e_no & x_rs & y_c0  & a_sum & r_pc & m_no  & s_sb   & X"2" when X"64",-- jlr1
  e_no & x_c0 & y_c0  & a_sum & r_no & m_no  & s_bi8  & X"3" when X"65",-- mvi0
  e_no & x_c0 & y_c0  & a_sum & r_no & m_no  & s_bi8  & X"1" when X"67",-- mvs0

  e_no & x_c0 & y_c0  & a_sum & r_no & m_no  & s_bo4  & X"0" when X"68",-- nop
  e_no & x_rs & y_c0  & a_sum & r_no & m_no  & s_nul  & X"2" when X"69",-- beq0
  e_no & x_c0 & y_c0  & a_sum & r_no & m_fch & s_strt & X"7" when X"6a",-- ftch
  e_no & x_rs & y_c0  & a_sum & r_no & m_no  & s_nul  & X"1" when X"6b",-- bne0
  e_no & x_pc & y_i18 & a_sum & r_pc & m_no  & s_sb   & X"2" when X"6c",-- brch
  e_no & x_sr & y_c16 & a_sll & r_ss & m_no  & s_sb   & X"7" when X"6e",-- req1

  e_no & x_c0 & y_c0  & a_sum & r_no & m_no  & s_bo4  & X"0" when X"70",-- nop
  e_no & x_pc & y_i28 & a_sum & r_pc & m_no  & s_sb   & X"2" when X"71",-- j0
  e_no & x_pc & y_c0  & a_sum & r_31 & m_no  & s_sb   & X"e" when X"73",-- jl0
  e_no & x_pc & y_i28 & a_sum & r_pc & m_no  & s_sb   & X"2" when X"74",-- jl1
  e_no & x_ia & y_c0  & a_sum & r_pc & m_no  & s_sb   & X"f" when X"75",-- rfe0
  e_no & x_sr & y_c16 & a_srl & r_sr & m_no  & s_sb   & X"2" when X"76",-- rfe1
  e_no & x_c0 & y_i28 & a_sum & r_tv & m_no  & s_lb   & X"f" when X"77",-- trp0

  e_no & x_pc & y_c4  & a_sum & r_pc & m_no  & s_bo16 & X"0" when X"7c",-- init
  e_no & x_pc & y_c0  & a_sum & r_si & m_no  & s_sb   & X"b" when X"7e",-- req0

  e_il & x_c0 & y_c0  & a_sum & r_no & m_no  & s_strt & X"0" when others;

	-- ###--------------------------------------------------------###
	-- #   define the micro-instruction's value in case of reset	#
	-- ###--------------------------------------------------------###

  RESTMI_X <= e_no & x_c0 & y_c0 & a_sum & r_no & m_fch & s_strt & X"7";

	-- ###--------------------------------------------------------###
	-- #   assign micro-instruction and micro-instruction's address	#
	-- # registers							#
	-- #     - in any case if the firmware is not freezed save	#
	-- #       the address in the address register			#
	-- #								#
	-- #     - if the firmware is not freezed depending on the	#
	-- #       reset condition write either the output of the	#
	-- #       micro-ROM or the reset micro-instruction in the	#
	-- #       register						#
	-- ###--------------------------------------------------------###

mic_ins : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE)
begin
 MICADR_R <= guarded MICADR_S ;

 MICINS_R <= guarded RESTMI_X when (RESET_R = '1') else
                     MICINS_S ;
end block ;

	-- ###--------------------------------------------------------###
	-- #   extract the immediate from in the instruction register	#
	-- #								#
	-- #     imd16 : 16-bit immediate with sign extension		#
	-- #     imd18 : 16-bit short branch offset with sign extension	#
	-- #     imd28 : 26-bit long  branch offset with sign extension	#
	-- ###--------------------------------------------------------###

IMD16_S (15 downto  0) <= IR_R (15 downto 0) ;
IMD16_S (31 downto 16) <= X"ffff" when (IR_R (15) = '1') else
                          X"0000" ;

IMD18_S (17 downto  0) <= IR_R (15 downto 0) & B"00";
IMD18_S (31 downto 18) <= X"fff" & B"11" when (IR_R (15) = '1') else
                          X"000" & B"00" ;

IMD28_S (27 downto  0) <= IR_R (25 downto 0) & B"00";
IMD28_S (31 downto 28) <= X"f" when (IR_R (25) = '1') else
                          X"0" ;

	-- ###--------------------------------------------------------###
	-- #   i format instructions					#
	-- ###--------------------------------------------------------###

with OPCOD_S select
IFORMT_S <= '1' when addi_i | subi_i |
                     slli_i | srli_i | srai_i   | lhi_i    |
                     seqi_i | snei_i | sgei_i   | slei_i   |
                     sgti_i | slti_i |
                     andi_i | ori_i  | xori_i   |
                     sw_i   | sb_i   | lbu_i    |
                     lw_i   |
                     beqz_i | bnez_i                       ,
            '0' when others                                ;

	-- ###--------------------------------------------------------###
	-- #   read and write pointers from register file		#
	-- ###--------------------------------------------------------###

WRTPNT_S <= B"11111"            when (CTLRES_S = r_31) else
            IR_R (20 downto 16) when (IFORMT_S = '1'  ) else
            IR_R (15 downto 11) ;

with CTLOPX_S select
REDPNT_S <= IR_R (25 downto 21) when x_rs  ,
            IR_R (20 downto 16) when others;

	-- ###--------------------------------------------------------###
	-- #   register read from the register file			#
	-- ###--------------------------------------------------------###

with REDPNT_S select
REDREG_S <= R0_R  when B"00000" ,
            R1_R  when B"00001" ,
            R2_R  when B"00010" ,
            R3_R  when B"00011" ,
            R4_R  when B"00100" ,
            R5_R  when B"00101" ,
            R6_R  when B"00110" ,
            R7_R  when B"00111" ,
            R8_R  when B"01000" ,
            R9_R  when B"01001" ,
            R10_R when B"01010" ,
            R11_R when B"01011" ,
            R12_R when B"01100" ,
            R13_R when B"01101" ,
            R14_R when B"01110" ,
            R15_R when B"01111" ,
            R16_R when B"10000" ,
            R17_R when B"10001" ,
            R18_R when B"10010" ,
            R19_R when B"10011" ,
            R20_R when B"10100" ,
            R21_R when B"10101" ,
            R22_R when B"10110" ,
            R23_R when B"10111" ,
            R24_R when B"11000" ,
            R25_R when B"11001" ,
            R26_R when B"11010" ,
            R27_R when B"11011" ,
            R28_R when B"11100" ,
            R29_R when B"11101" ,
            R30_R when B"11110" ,
            R31_R when B"11111" ;

	-- ###--------------------------------------------------------###
	-- #   x and y operands						#
	-- ###--------------------------------------------------------###

with CTLOPX_S select
OPERX_S <= REDREG_S when x_rs   ,
           REDREG_S when x_rt   ,
           PC_R     when x_pc   ,
           AD_R     when x_ad   ,
           SR_R     when x_sr   ,
           IAR_R    when x_ia   ,
           TVR_R    when x_tv   ,
           c0       when x_c0   ,
           cb       when x_cb   ,
           ch       when x_ch   ,
           c0       when others ;

with CTLOPY_S select
OPERY_S <= IMD16_S when y_i16  ,
           IMD18_S when y_i18  ,
           IMD28_S when y_i28  ,
           DT_R    when y_dt   ,
           AD_R    when y_ad   ,
           c0      when y_c0   ,
           c4      when y_c4   ,
           c16     when y_c16  ,
           c0      when others ;

	-- ###--------------------------------------------------------###
	-- #   adder's x and y operands					#
	-- ###--------------------------------------------------------###

ADDX_S <= OPERX_S;

with CTLALU_S select
ADDY_S (31 downto 0) <=      OPERY_S  when a_sum | a_smv,
                        not (OPERY_S) when others;

	-- ###--------------------------------------------------------###
	-- #   adder's carry and result					#
	-- ###--------------------------------------------------------###

with CTLALU_S select
ADDCRY_S (0) <= '0'  when a_sum | a_smv,
                '1'  when others;

ADDCRY_S (32 downto 1) <= (ADDX_S and ADDY_S                ) or
                          (ADDX_S and ADDCRY_S (31 downto 0)) or
                          (ADDY_S and ADDCRY_S (31 downto 0)) ;

ADDRES_S <=  ADDX_S xor ADDY_S xor ADDCRY_S (31 downto 0);

	-- ###--------------------------------------------------------###
	-- #   adder's overflow						#
	-- ###--------------------------------------------------------###

ADDOVR_S <= ADDCRY_S (32) xor ADDCRY_S (31);

	-- ###--------------------------------------------------------###
	-- #   test and set bits :					#
	-- #     seq : x  = y						#
	-- ###--------------------------------------------------------###

  SEQ_S <= '1' when (ADDRES_S = X"00000000") else
           '0' ;

  SGT_S <= '1' when ((OPERX_S (31) xor OPERY_S (31) ='0') and
                     (ADDRES_S (31) = '0') and (SEQ_S = '0')) else
         '1' when (OPERX_S (31) = '0' and OPERY_S (31) = '1')  else
         '0' ;

  SNE_S <= not (SEQ_S) ;
  SGE_S <=      SEQ_S or SGT_S;
  SLE_S <=      SEQ_S or SLT_S;
  SLT_S <= not (SGE_S);

	-- ###--------------------------------------------------------###
	-- #   shifter							#
	-- ###--------------------------------------------------------###

  SHIN_S   <= X"00000000" when CTLALU_S     = a_srl else	-- logical
              X"ffffffff" when OPERX_S (31) = '1'   else	-- arithm.
              X"00000000" ;					-- arithm.

  with OPERY_S (4 downto 0) select
  SHLFT_S <= OPERX_S (31 downto 0)                     when B"00000" ,
             OPERX_S (30 downto 0) & c0 (31)           when B"00001" ,
             OPERX_S (29 downto 0) & c0 (31 downto 30) when B"00010" ,
             OPERX_S (28 downto 0) & c0 (31 downto 29) when B"00011" ,
             OPERX_S (27 downto 0) & c0 (31 downto 28) when B"00100" ,
             OPERX_S (26 downto 0) & c0 (31 downto 27) when B"00101" ,
             OPERX_S (25 downto 0) & c0 (31 downto 26) when B"00110" ,
             OPERX_S (24 downto 0) & c0 (31 downto 25) when B"00111" ,
             OPERX_S (23 downto 0) & c0 (31 downto 24) when B"01000" ,
             OPERX_S (22 downto 0) & c0 (31 downto 23) when B"01001" ,
             OPERX_S (21 downto 0) & c0 (31 downto 22) when B"01010" ,
             OPERX_S (20 downto 0) & c0 (31 downto 21) when B"01011" ,
             OPERX_S (19 downto 0) & c0 (31 downto 20) when B"01100" ,
             OPERX_S (18 downto 0) & c0 (31 downto 19) when B"01101" ,
             OPERX_S (17 downto 0) & c0 (31 downto 18) when B"01110" ,
             OPERX_S (16 downto 0) & c0 (31 downto 17) when B"01111" ,
             OPERX_S (15 downto 0) & c0 (31 downto 16) when B"10000" ,
             OPERX_S (14 downto 0) & c0 (31 downto 15) when B"10001" ,
             OPERX_S (13 downto 0) & c0 (31 downto 14) when B"10010" ,
             OPERX_S (12 downto 0) & c0 (31 downto 13) when B"10011" ,
             OPERX_S (11 downto 0) & c0 (31 downto 12) when B"10100" ,
             OPERX_S (10 downto 0) & c0 (31 downto 11) when B"10101" ,
             OPERX_S (9  downto 0) & c0 (31 downto 10) when B"10110" ,
             OPERX_S (8  downto 0) & c0 (31 downto  9) when B"10111" ,
             OPERX_S (7  downto 0) & c0 (31 downto  8) when B"11000" ,
             OPERX_S (6  downto 0) & c0 (31 downto  7) when B"11001" ,
             OPERX_S (5  downto 0) & c0 (31 downto  6) when B"11010" ,
             OPERX_S (4  downto 0) & c0 (31 downto  5) when B"11011" ,
             OPERX_S (3  downto 0) & c0 (31 downto  4) when B"11100" ,
             OPERX_S (2  downto 0) & c0 (31 downto  3) when B"11101" ,
             OPERX_S (1  downto 0) & c0 (31 downto  2) when B"11110" ,
             OPERX_S (0)           & c0 (31 downto  1) when B"11111" ;

  with OPERY_S (4 downto 0) select
  SHRIT_S <=                        OPERX_S (31 downto  0) when B"00000" ,
             SHIN_S ( 0         ) & OPERX_S (31 downto  1) when B"00001" ,
             SHIN_S ( 1 downto 0) & OPERX_S (31 downto  2) when B"00010" ,
             SHIN_S ( 2 downto 0) & OPERX_S (31 downto  3) when B"00011" ,
             SHIN_S ( 3 downto 0) & OPERX_S (31 downto  4) when B"00100" ,
             SHIN_S ( 4 downto 0) & OPERX_S (31 downto  5) when B"00101" ,
             SHIN_S ( 5 downto 0) & OPERX_S (31 downto  6) when B"00110" ,
             SHIN_S ( 6 downto 0) & OPERX_S (31 downto  7) when B"00111" ,
             SHIN_S ( 7 downto 0) & OPERX_S (31 downto  8) when B"01000" ,
             SHIN_S ( 8 downto 0) & OPERX_S (31 downto  9) when B"01001" ,
             SHIN_S ( 9 downto 0) & OPERX_S (31 downto 10) when B"01010" ,
             SHIN_S (10 downto 0) & OPERX_S (31 downto 11) when B"01011" ,
             SHIN_S (11 downto 0) & OPERX_S (31 downto 12) when B"01100" ,
             SHIN_S (12 downto 0) & OPERX_S (31 downto 13) when B"01101" ,
             SHIN_S (13 downto 0) & OPERX_S (31 downto 14) when B"01110" ,
             SHIN_S (14 downto 0) & OPERX_S (31 downto 15) when B"01111" ,
             SHIN_S (15 downto 0) & OPERX_S (31 downto 16) when B"10000" ,
             SHIN_S (16 downto 0) & OPERX_S (31 downto 17) when B"10001" ,
             SHIN_S (17 downto 0) & OPERX_S (31 downto 18) when B"10010" ,
             SHIN_S (18 downto 0) & OPERX_S (31 downto 19) when B"10011" ,
             SHIN_S (19 downto 0) & OPERX_S (31 downto 20) when B"10100" ,
             SHIN_S (20 downto 0) & OPERX_S (31 downto 21) when B"10101" ,
             SHIN_S (21 downto 0) & OPERX_S (31 downto 22) when B"10110" ,
             SHIN_S (22 downto 0) & OPERX_S (31 downto 23) when B"10111" ,
             SHIN_S (23 downto 0) & OPERX_S (31 downto 24) when B"11000" ,
             SHIN_S (24 downto 0) & OPERX_S (31 downto 25) when B"11001" ,
             SHIN_S (25 downto 0) & OPERX_S (31 downto 26) when B"11010" ,
             SHIN_S (26 downto 0) & OPERX_S (31 downto 27) when B"11011" ,
             SHIN_S (27 downto 0) & OPERX_S (31 downto 28) when B"11100" ,
             SHIN_S (28 downto 0) & OPERX_S (31 downto 29) when B"11101" ,
             SHIN_S (29 downto 0) & OPERX_S (31 downto 30) when B"11110" ,
             SHIN_S (30 downto 0) & OPERX_S (31)           when B"11111" ;

	-- ###--------------------------------------------------------###
	-- #   result out of alu					#
	-- ###--------------------------------------------------------###

  with CTLALU_S select
  RESULT_S <= ADDRES_S                  when a_sum | a_smv,
              ADDRES_S                  when a_dif | a_dfv,
              OPERX_S and OPERY_S       when a_and        ,
              OPERX_S or  OPERY_S       when a_or         ,
              OPERX_S xor OPERY_S       when a_xor        ,
              SHLFT_S                   when a_sll        ,
              SHRIT_S                   when a_srl        ,
              SHRIT_S                   when a_sra        ,
              c0 (31 downto 1) & SEQ_S  when a_seq        ,
              c0 (31 downto 1) & SNE_S  when a_sne        ,
              c0 (31 downto 1) & SGE_S  when a_sge        ,
              c0 (31 downto 1) & SGT_S  when a_sgt        ,
              c0 (31 downto 1) & SLE_S  when a_sle        ,
              c0 (31 downto 1) & SLT_S  when a_slt        ,
              c0                        when others       ;

	-- ###--------------------------------------------------------###
	-- #   checking the result out of alu				#
	-- ###--------------------------------------------------------###

RESNUL_S <= '1' when (RESULT_S = X"00000000") else
            '0' ;

	-- ###--------------------------------------------------------###
	-- #   external storage access :				#
	-- #     - access type (word, byte)				#
	-- #     - valid bytes						#
	-- ###--------------------------------------------------------###

WORD_S <= '1' when (CTLMEM_S = m_fch or CTLMEM_S = m_rw or CTLMEM_S = m_ww) else
          '0' ;

BYTE_S <= '1' when (CTLMEM_S = m_rb  or CTLMEM_S = m_wb                   ) else
          '0' ;

BYTSEL_S <= "1111" when (WORD_S = '1'                             ) else
            "0001" when (BYTE_S = '1' and AD_R (1 downto 0) = "11") else
            "0010" when (BYTE_S = '1' and AD_R (1 downto 0) = "10") else
            "0100" when (BYTE_S = '1' and AD_R (1 downto 0) = "01") else
            "1000" when (BYTE_S = '1' and AD_R (1 downto 0) = "00") else
            "0000" ;

	-- ###--------------------------------------------------------###
	-- #   data from external storage read and aligned		#
	-- ###--------------------------------------------------------###

REDDAT_S (31 downto 8) <= DATA (31 downto  8) ;
REDDAT_S ( 7 downto 0) <= DATA ( 7 downto  0) when (BYTSEL_S (3) = '1') else
                          DATA (15 downto  8) when (BYTSEL_S (2) = '1') else
                          DATA (23 downto 16) when (BYTSEL_S (1) = '1') else
                          DATA (31 downto 24) ;

	-- ###--------------------------------------------------------###
	-- #   prepare the new status to be written into the 16 least	#
	-- # significant bits of sr in case of interruption or exception#
	-- ###--------------------------------------------------------###

NEWSR_X <= IT_R & OVR_R & DAV_R & ICO_R & IAV_R & "0000" & CPURST_R & "000";

	-- ###--------------------------------------------------------###
	-- #   registers' write enable					#
	-- ###--------------------------------------------------------###

with CTLRES_S select
WENSR_S  <= not EXCRQS_X when r_sr  ,
            '1'          when r_ss  ,
            '0'          when others;

with CTLRES_S select
WENIAR_S <= not EXCRQS_X when r_ia  ,
            '1'          when r_si  ,
            '0'          when others;

WENTVR_S <= not EXCRQS_X when (CTLRES_S = r_tv                    ) else
            '0'          ;
WENPC_S  <= not EXCRQS_X when (CTLRES_S = r_pc                    ) else
            '0'          ;
WENAD_S  <= not EXCRQS_X when (CTLRES_S = r_ad                    ) else
            '0'          ;
WENREG_S <= not EXCRQS_X when (CTLRES_S = r_rd  or CTLRES_S = r_31) else
            '0'          ;
WENDT_S  <= not EXCRQS_X when (CTLMEM_S = m_rw  or CTLMEM_S = m_rb) else
            '0'          ;
WENIR_S  <= not EXCRQS_X when (CTLMEM_S = m_fch                   ) else
            '0'          ;

	-- ###--------------------------------------------------------###
	-- #   write the result into registers :			#
	-- #     sr  : status register					#
	-- #     iar : interrupt address register			#
	-- #     tvr : trap vector register				#
	-- #     pc  : program counter					#
	-- #     ad  : internal address register			#
	-- ###--------------------------------------------------------###

status : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENSR_S = '1')
begin
  SR_R <= guarded RESULT_S (31 downto  0)           when CTLRES_S = r_sr else
                  RESULT_S (31 downto 16) & NEWSR_X;
end block;

it_adr : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENIAR_S = '1')
begin
  IAR_R <= guarded RESULT_S;
end block;

trap_v : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENTVR_S = '1')
begin
  TVR_R <= guarded RESULT_S;
end block;

prg_cnt : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENPC_S = '1')
begin
  PC_R <= guarded RESULT_S;
end block;

address : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENAD_S = '1')
begin
  AD_R <= guarded RESULT_S;
end block;

	-- ###--------------------------------------------------------###
	-- #   write the value read on data bus into registers :	#
	-- #     dt  : data register					#
	-- #     ir  : instruction register				#
	-- ###--------------------------------------------------------###

data_in : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENDT_S = '1')
begin
  DT_R <= guarded REDDAT_S;
end block ;

instruc : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE and WENIR_S = '1')
begin
  IR_R  <= guarded REDDAT_S;
end block ;

	-- ###--------------------------------------------------------###
	-- #   write integre registers					#
	-- ###--------------------------------------------------------###

r1  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00001" and
             WENREG_S = '1')
begin
  R1_R  <= guarded RESULT_S;
end block;

r2  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00010" and
             WENREG_S = '1')
begin
  R2_R  <= guarded RESULT_S;
end block;

r3  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00011" and
             WENREG_S = '1')
begin
  R3_R  <= guarded RESULT_S;
end block;

r4  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00100" and
             WENREG_S = '1')
begin
  R4_R  <= guarded RESULT_S;
end block;

r5  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00101" and
             WENREG_S = '1')
begin
  R5_R  <= guarded RESULT_S;
end block;

r6  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00110" and
             WENREG_S = '1')
begin
  R6_R  <= guarded RESULT_S;
end block;

r7  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "00111" and
             WENREG_S = '1')
begin
  R7_R  <= guarded RESULT_S;
end block;

r8  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01000" and
             WENREG_S = '1')
begin
  R8_R  <= guarded RESULT_S;
end block;

r9  : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01001" and
             WENREG_S = '1')
begin
  R9_R  <= guarded RESULT_S;
end block;

r10 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01010" and
             WENREG_S = '1')
begin
  R10_R <= guarded RESULT_S;
end block;

r11 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01011" and
             WENREG_S = '1')
begin
  R11_R <= guarded RESULT_S;
end block;

r12 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01100" and
             WENREG_S = '1')
begin
  R12_R <= guarded RESULT_S;
end block;

r13 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01101" and
             WENREG_S = '1')
begin
  R13_R <= guarded RESULT_S;
end block;

r14 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01110" and
             WENREG_S = '1')
begin
  R14_R <= guarded RESULT_S;
end block;

r15 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "01111" and
             WENREG_S = '1')
begin
  R15_R <= guarded RESULT_S;
end block;

r16 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10000" and
             WENREG_S = '1')
begin
  R16_R <= guarded RESULT_S;
end block;

r17 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10001" and
             WENREG_S = '1')
begin
  R17_R <= guarded RESULT_S;
end block;

r18 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10010" and
             WENREG_S = '1')
begin
  R18_R <= guarded RESULT_S;
end block;

r19 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10011" and
             WENREG_S = '1')
begin
  R19_R <= guarded RESULT_S;
end block;

r20 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10100" and
             WENREG_S = '1')
begin
  R20_R <= guarded RESULT_S;
end block;

r21 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10101" and
             WENREG_S = '1')
begin
  R21_R <= guarded RESULT_S;
end block;

r22 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10110" and
             WENREG_S = '1')
begin
  R22_R <= guarded RESULT_S;
end block;

r23 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "10111" and
             WENREG_S = '1')
begin
  R23_R <= guarded RESULT_S;
end block;

r24 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11000" and
             WENREG_S = '1')
begin
  R24_R <= guarded RESULT_S;
end block;

r25 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11001" and
             WENREG_S = '1')
begin
  R25_R <= guarded RESULT_S;
end block;

r26 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11010" and
             WENREG_S = '1')
begin
  R26_R <= guarded RESULT_S;
end block;

r27 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11011" and
             WENREG_S = '1')
begin
  R27_R <= guarded RESULT_S;
end block;

r28 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11100" and
             WENREG_S = '1')
begin
  R28_R <= guarded RESULT_S;
end block;

r29 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11101" and
             WENREG_S = '1')
begin
  R29_R <= guarded RESULT_S;
end block;

r30 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11110" and
             WENREG_S = '1')
begin
  R30_R <= guarded RESULT_S ;
end block;

r31 : block (CKFRZ_S  = '0' and not CKFRZ_S'STABLE and WRTPNT_S = "11111" and
             WENREG_S = '1')
begin
  R31_R <= guarded RESULT_S;
end block;

	-- ###--------------------------------------------------------###
	-- #   exceptions						#
	-- ###--------------------------------------------------------###

with CTLALU_S select
OVRFLO_X <= ADDOVR_S when a_smv | a_dfv ,
            '0'      when others          ;

ILLINS_X <= '1' when (CTLEXC_S = e_il) else
            '0';

OPVIOL_X <= SR_R (0)  and PRVINS_X when (CTLSEQ_S = s_bo16) else
            '0'                   ;

IAALGN_X <= PC_R (1)  or  PC_R (0) when (CTLMEM_S = m_fch) else
            '0'                  ;

IASGMT_X <= PC_R (31) and SR_R (0) when (CTLMEM_S = m_fch) else
            '0'                    ;

with CTLMEM_S select
DAALGN_X <= AD_R (1) or AD_R (0) when m_ww  | m_rw,
            '0'                  when others;

with CTLMEM_S select
DASGMT_X <= AD_R (31) and SR_R (0) when m_ww  | m_wb | m_rw | m_rb,
            '0'                    when others;

	-- ###--------------------------------------------------------###
	-- #   assign exception registers				#
	-- ###--------------------------------------------------------###

except : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE)
begin

  OVR_R <= guarded OVRFLO_X                      when (CTLRES_S = r_ss) else
                   OVRFLO_X or OVR_R             ;

  DAV_R <= guarded DAALGN_X or DASGMT_X          when (CTLRES_S = r_ss) else
                   DAALGN_X or DASGMT_X or DAV_R ;

  ICO_R <= guarded OPVIOL_X or ILLINS_X          when (CTLRES_S = r_ss) else
                   OPVIOL_X or ILLINS_X or ICO_R ;

  IAV_R <= guarded IAALGN_X or IASGMT_X          when (CTLRES_S = r_ss) else
                   IAALGN_X or IASGMT_X or IAV_R ;
end block;

	-- ###--------------------------------------------------------###
	-- #   assign registers (set a register to indicate effective	#
	-- # reset at firmware level)					#
	-- ###--------------------------------------------------------###

cpu_reseted : block (CKFRZ_S = '0' and not CKFRZ_S'STABLE)
begin
  CPURST_R <= guarded RESET_R             when ((CTLRES_S = r_ss) and
                                                (FRZ      = '0' )) else
                      RESET_R or CPURST_R ;
end block;

	-- ###--------------------------------------------------------###
	-- #   assign registers (those independent from the execution	#
	-- # of an instruction)						#
	-- ###--------------------------------------------------------###

ext_it : block (CK_S = '0' and not CK_S'STABLE)
begin
  FRZ_R   <= guarded FRZ              ;
  RESET_R <= guarded RESET            when (FRZ = '0') else
                     RESET or RESET_R ;

  IT_R    <= guarded not IT           when ((CTLRES_S = r_ss) and
                                            (FRZ      = '0' )    ) else
                     not IT or IT_R   ;
end block;

	-- ###--------------------------------------------------------###
	-- #   assign outputs :						#
	-- #     - desable write accesses on exception			#
	-- #     - enable output tristate buffers of data bus only on	#
	-- #       high level of (delayed) ck to avoid conflicts	#
	-- #     - enable output tristate buffers only if the chip is	#
	-- #       not freezed						#
	-- #     - align datas before writing on data bus		#
	-- ### ------------------------------------------------------ ###

data : block ( CKDLY6_S = '1'   and (FRZ and FRZ_R) = '0' and
              (CTLMEM_S = m_ww  or   CTLMEM_S       = m_wb))
begin
  with CTLMEM_S select
  DATA <= guarded RESULT_S                                        when m_ww,
                  RESULT_S (7 downto 0) & RESULT_S (7 downto 0) &
                  RESULT_S (7 downto 0) & RESULT_S (7 downto 0)   when others;
end block ;

adr : block ((FRZ and FRZ_R) = '0')
begin
  with CTLMEM_S select
  ADR <= guarded AD_R when m_ww | m_wb | m_rw | m_rb,
                 PC_R when others;
end block;

SCOUT <= '0';

BYTE  <= BYTSEL_S when (EXCRQS_X = '0') else
         "0000"   ;

RW    <= '0' when (CTLMEM_S = m_ww or CTLMEM_S = m_wb) else
         '1' ;


end BEHAVIOURAL;
