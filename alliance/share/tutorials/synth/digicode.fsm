entity digicode is
  port (
	ck, reset, day, O:in bit;
	i:in bit_vector (3 downto 0);
	door, warn:out bit;
	vdd, vss:in bit
	);
end digicode;

architecture MOORE of digicode is
type ETAT_TYPE is (S0, S1, S2, S3, S_WAIT, S_OPEN, S_WARN);
signal NEXT_STATE, CURRENT_STATE:ETAT_TYPE;

-- pragma CURRENT_STATE CURRENT_STATE
-- pragma NEXT_STATE NEXT_STATE
-- pragma CLOCK ck

constant CODE0 : bit_vector (3 downto 0):= X"5";
constant CODE1 : bit_vector (3 downto 0):= X"3";
constant CODE2 : bit_vector (3 downto 0):= X"C";
constant CODE3 : bit_vector (3 downto 0):= X"1";
constant CODE4 : BIT_vector (3 downto 0):= X"7";

begin
process (CURRENT_STATE, i, reset, day, O)
begin
if (reset = '1')
     	then NEXT_STATE <= S_WAIT;
		door <= '0';
		warn <= '0';
	else
	case CURRENT_STATE is
		when S_WAIT =>
			if (O = '1')
				then if (day = '1')
     					then NEXT_STATE <= S_OPEN;
						door <= '1';
					else
						NEXT_STATE <= S_WAIT;
						door <= '0';
     					end if;
     					warn <='0';
     				else if (i = CODE0)
     					then NEXT_STATE <= S0;
						warn <= '0';
					else
						NEXT_STATE <= S_WARN;
						warn <= '1';
     					end if;
     						door <='0';
     				end if;
     		when S0 =>
			if ((day = '1') and (O = '1'))
  				then NEXT_STATE <= S_OPEN;
					door <= '1';
					warn <= '0';
				else
					if (i = CODE1)
     						then NEXT_STATE <= S1;
							warn <= '0';
						else
							NEXT_STATE <= S_WARN;
							warn <= '1';
     						end if;
     					door <='0';
     				end if;
     		when S1 =>
			if ((day = '1') and (O = '1'))
  				then NEXT_STATE <= S_OPEN;
					door <= '1';
					warn <= '0';
				else
					if (i = CODE2)
     						then NEXT_STATE <= S2;
							warn <= '0';
						else
							NEXT_STATE <= S_WARN;
							warn <= '1';
     						end if;
     					door <='0';
     				end if;
     		when S2 =>
			if ((day = '1') and (O = '1'))
  				then NEXT_STATE <= S_OPEN;
					door <= '1';
					warn <= '0';
				else
					if (i = CODE3)
						then NEXT_STATE <= S3;
							warn <= '0';
						else
							NEXT_STATE <= S_WARN;
							warn <= '1';
     						end if;
     					door <='0';
     				end if;
     		when S3 =>
			if ((day = '1') and (O = '1'))
  				then NEXT_STATE <= S_OPEN;
					door <= '1';
					warn <= '0';
				else
					if (i = CODE4)
     						then NEXT_STATE <= S_OPEN;
							door <= '1';
							warn <= '0';
						else
							NEXT_STATE <= S_WARN;
							door <= '0';
							warn <= '1';
     						end if;
     				end if;
     		when S_WARN =>
     			NEXT_STATE <= S_WARN;
     			door <='0';
			warn <= '1';

     		when S_OPEN =>
     			NEXT_STATE <= S_OPEN;
			door <= '1';
			warn <= '0';

     		when others =>
     			assert ('1')
			report "illegal state";
     	end case;
     end if;
end process;
process (ck)
	 begin
	 if (ck = '1' and not ck 'stable)
	     then CURRENT_STATE <= NEXT_STATE;
     end if;
end process;
end MOORE;
