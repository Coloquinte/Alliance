%%%%%%%%%%%%%%%%%%%%
%
% The addaccu tutorial.
% Original Version 1.0 in text form by Francois Pecheux
% Version for Alliance releases 2.0 and up by Frederic Petrot
% Modified by czo for Alliance release 4.0 (01/2000)
% TODO : no fully working, needs some adjustements
% $Id: addaccu.tex,v 1.1 2000/01/20 16:09:58 czo Exp $
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass{article}
\usepackage{palatino,doublespace,here,psfig,fancybox}
\textwidth 15cm
\textheight 23cm
\oddsidemargin  +0.75cm
\evensidemargin -0.75cm
\setstretch{1.2}
%%%%%%%%%%%%%%%
% Setting the width of the verbatim parts according to 80 tt chars
% Since it is tt, any char is fine
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newlength{\verbatimbox}
\settowidth{\verbatimbox}{\scriptsize\tt 
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
}
\newenvironment{framedverbatim}
 {\VerbatimEnvironment\par\noindent\scriptsize
  \begin{Sbox}\begin{minipage}{\verbatimbox}\begin{Verbatim}}%
 {\end{Verbatim}\end{minipage}\end{Sbox}
  \setlength{\fboxsep}{3mm}\center\shadowbox{\TheSbox}\normalsize\par\noindent}
\newenvironment{phraseverbatim}
 {\VerbatimEnvironment\par\vspace*{2mm}\noindent\footnotesize
  \begin{Sbox}\begin{minipage}{.979\textwidth}\begin{Verbatim}}%
 {\end{Verbatim}\end{minipage}\end{Sbox}\setlength{\shadowsize}{2pt}%
 \shadowbox{\TheSbox}\normalsize\par\noindent}
 
 

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\begin{center}
\Huge First steps in using \bf Alliance\\
\Huge the \texttt{addaccu} tutorial
\end{center}
\vspace{2cm}
\begin{center}
Abstract

\begin{quote}
\em
This tutorial introduces the design flow to be used in the
\textbf{Alliance} CAD framework for the design and verification of a 
standard cells circuit, including the pads.
Each step of the desgin flow is supported by one or more specific 
tools, whose use is briefly explained.

This text is meant to be simple and comprehensive, and is to be used
to get \emph{into} the system.
Should something be unclear or wrong, please indicate this by sending
an e-mail to \texttt{alliance-support@lip6.fr}.
\rm
\end{quote}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In this tutorial, you will learn the practical use of some basic
\textbf{Alliance} tools by building a very simple circuit from scratch.
It is recommended that you read the \texttt{overview.ps} file before
proceeding, as it describes the main steps of the design conceptually.

Before we proceed to the tutorial, you must make sure that the
\textbf{Alliance} tools are readilly available when invoking them at the 
prompt.
The prompt in represented in the following text by the symbol~:
\begin{phraseverbatim}
~fred/addaccu %-)
\end{phraseverbatim}
In this system, \texttt{fred} is the user, \texttt{addaccu} is the current
directory, and \texttt{\%-)} is supposed to give us courage!

Try issuing the following command to check that \textbf{Alliance} is
correctly installed:

\begin{phraseverbatim}
~fred/addaccu %-) yagle
\end{phraseverbatim}

If everything is working, you get the following result:

\begin{framedverbatim}
YAGLE 2.00
Usage   : yagle [options] <file1> [file2]
Options : -i     reads the '.inf' file
          -v     vectorises the vhdl description
          -p=n   n is the depth for functional analysis
          -nc    no detection of complex gates
          -nl    no latch detection
          -fcl   transistor netlist detection
          -elp   use the technology file '.elp'
          -d     generates a .cns file
          -b     transistor orientation
          -z     functional analysis through HZ nodes
          -os    only one vdd and vss in the vhdl description
          -nh    generates a hierarchical cone netlist
          file2  is the vhdl file to be generated (default is file1)
          -t     display execution trace
\end{framedverbatim}

If it does not work, please abort the tutorial and fix the pathnames.

We will assume that the user is running a \texttt{c-like} shell, like
\texttt{csh} or \texttt{tcsh}.
If you run a \texttt{sh-like} shell, please refer to your
documentation.

Typically do:

\begin{phraseverbatim}
~fred/addaccu %-) setenv ALLIANCE_TOP  /usr/local/cad/alliance
~fred/addaccu %-) setenv PATH $ALLIANCE_TOP/bin:$PATH
\end{phraseverbatim}
Where we assume that \textbf{Alliance} has been installed under
\texttt{/usr/local/cad/alliance} directory.
In the sequel, we will assume that the \verb+$ALLIANCE_TOP+ variable is
properly set up.

All the tools used in this tutorial are documented at least with a
manual page.
Each manual can be accessed using the \texttt{man \it tool} command.
You may have to do a:
\small
\begin{phraseverbatim}
~fred/addaccu %-) setenv MANPATH $ALLIANCE_TOP/man:$MANPATH
\end{phraseverbatim}
\normalsize
in order to have the manual accessible.

The tutorial is organized around the following sections:
\begin{itemize}
\item Chip overview (page~\pageref{chip});
\item Design flow (page~\pageref{desginflow});
\item Execution environment set-up (page~\pageref{setup});
\item Behavioral capture and simulation (page~\pageref{beh});
\item Netlist capture (page~\pageref{netlist});
\item Core layout generation (page~\pageref{layout});
\item Core layout verification (page~\pageref{lv});
\item Core to pads routing (page~\pageref{pads});
\item Chip visualization (page~\pageref{graal});
\item Functional abstraction (page~\pageref{fa});
\item Further verifications (page~\pageref{verif});
\item Symbolic to real technology conversion (page~\pageref{sr}).
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chip overview}
\label{chip}
The picture in the Figure~\ref{archi} shows the architecture of the 
small chip that will be our example all along this tutorial.
As you can see, the circuit is pretty small: it mostly consists in a 
four bit adder, a four bit register, and a 2 to 1 four bit multiplexer.

\begin{figure}\center
\leavevmode\psfig{figure=addaccu.eps,width=8cm,angle=-90}
\caption{\label{archi}Architecture of the \texttt{addaccu} circuit.}
\end{figure}

Inputs are located on the left side of the picture, and outputs are 
located on the right side.
We did not represent the power supplies on this schematic, but you'll
need them in order for the chip to work!

The circuit performs an addition between either the \texttt{b[3:0]} and 
\texttt{a[3:0]} inputs when \texttt{sel} is set to 0, or between
\texttt{b[3:0]} and the contents of the four bit register when \texttt{sel} 
is set to 1.
The content of the register is overwriten by the value of the outputs 
\texttt{s[3:0]} on each falling edge of the clock, \texttt{ck}.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Design flow}
\label{desginflow}

You are now ready to actually design the chip and use the
\textbf{Alliance} tools.
The design flow for this little example is composed of 5 main 
steps:
\begin{enumerate}
\item behavioral capture and simulation;
\item netlist capture and validation;
\item physical layout generation;
\item design validation;
\item symbolic to real conversion.
\end{enumerate}

As you will see, points 2 and 3 must be performed for each level of 
hierarchy.
In this example we distinguish two levels of hierarchy: the core 
level and the chip level.
At the core level, the leaf cells of the design belong to the
\textbf{Alliance} standard cells library.
At the chip level, the previous core and pads belonging to the
\textbf{Alliance} pad library are used.

The Figure~\ref{hier} below describes the circuit's hierarchy.

\begin{figure}\center
\leavevmode\psfig{figure=hierarchy.eps,width=14cm}
\caption{\label{hier}Hierarchical partitionning.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Execution environment set-up}
\label{setup}

Before you start examining the first phase of the design methodology, 
you first have to set up an execution environment for the
\textbf{Alliance} tools.

If the \textbf{Alliance} installation is set up properly, most of the 
tools can be executed without problem.
If the installation is only 
partial, or if you want to set a special feature of a tool, you will 
have to set some environment variables up.

The environment variables upon the which each tool depends are 
documented in each tool manual page.
However, some variables are really useful, and are in part documented 
here.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cell libraries path}

The first thing to know for this circuit is the actual location of 
the standard-cell library.
This library is located into \texttt{\$ALLIANCE\_TOP/cells/sclib}.
But indicating only one library is not enough, and as you can see in 
doing a \texttt{ls \$ALLIANCE\_TOP/cells}, several libraries are available.

The other library of interest here is the pad library, located in
\texttt{\$ALLIANCE\_TOP/cells/ring}.

To set up the cell library path, the following command is required:
\small
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_CATA_LIB $ALLIANCE_TOP/cells/scr:$ALLIANCE_TOP/cells/ring
\end{phraseverbatim}
\normalsize

This \texttt{setenv} instructs \textbf{Alliance} tools to search its cells 
in \texttt{/alliance/cells/scr} and then in \texttt{/alliance/cells/ring},
that respectively contains the standard cells and the pads.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User working directory}

You must specify the directory where the files generated by an
\textbf{Alliance} tool are to be located.

Please enter the following command:
\small
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_WORK_LIB .
\end{phraseverbatim}
\normalsize

In this case, the working directory is the current directory.
This library is scanned before the ones set in 
\texttt{MBK\_CATA\_LIB} when a tool loads a cell, and the only one 
used for writing a cell.
Note that \texttt{.} is the default value of this variable, so it is
not required to set it up usually.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{File formats}

One of the interesting features of \textbf{Alliance} is that different 
file formats can be used for both netlist and layout view.
However, 
in the design methodology we wish to promote, some formats are 
recommended.
The \texttt{vst}, structural \textbf{VHDL}, is dedicated to netlist 
specification.
The \texttt{al} format is dedicated to extracted layout representation.
The \texttt{ap} format is the usual layout format.

So, prior to generate a specification netlist, you shall type:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_LO vst
\end{phraseverbatim}

But if you wish to extract a netlist from the layout then you'll do:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_LO al
\end{phraseverbatim}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Behavioral capture and simulation}
\label{beh}

When designing a chip, the first thing to do is to write its 
behavior, based on its functional specifications.
In our example \texttt{addaccu}, we have to modelize an adder, a 
register and a multiplexer.
We also have to specify in the resulting behavior file that the adder 
may take as an input the result of a previous calculation or a new 
input stimuli.

Modern behavioral descriptions are written using the \textbf{VHDL} 
language, the most promoted and supported hardware description 
language.

Let us now edit the behavioral description of addaccu by issuing the 
following command:
\begin{phraseverbatim}
~fred/addaccu %-) vi addaccu.vbe
\end{phraseverbatim}

The \texttt{addaccu.vbe} file contains the behavioral description of the
circuit.
\texttt{Vbe} stands for \textbf{VHDL} behavioral description.
Although this tutorial does no intend to explain the arcanes of \textbf{VHDL} 
programming, it's worth noting some interesting points:
\begin{enumerate}
\item notice that the entity name, \texttt{addaccu}, identifies the circuit;
\item examine the circuit interface.
      You can recognize the terminals of the previous picture, plus 4 
      special terminals, known as supply terminals.
      The supply terminals are needed for the last stage of the 
      design, as the original behavioral description must be matched 
      with an "extracted" behavior.
      If this does not make immediate sense to you, do not panic, 
      everything will be clear in a moment;
\item take a look to the functional architecture of \texttt{addaccu}.
      When examining it, pay attention to the \texttt{reg\_bit~register} 
      names of the accumulator \texttt{reg}, as they will be used later 
      in the validation stage;
\item read carefully the functional description.
      With a little work, you can recognize the description of the 
      multiplexer, the equations of the adder, and the accumulator.
      It is very important to notice that the functional description 
      of the circuit assumes that edge-triggered latches are used.
\end{enumerate}

Once you have carefully examined this file, close it and get back to 
the shell prompt, for the \textbf{VHDL} compilation stage.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behavior compilation}

Once the behavioral description of the circuit is written, it is time 
for \textbf{VHDL} compilation.

You are now ready to compile \texttt{addaccu.vbe}.
As we do not have written simulation patterns yet, the only thing we 
can do is to test the syntax of the file we have just edited.

At the shell prompt level, please type:
\begin{phraseverbatim}
~fred/addaccu %-) asimut -b -c addaccu
\end{phraseverbatim}

This command instructs \texttt{asimut} to compile the behavioral file 
\texttt{addaccu.vbe}.
Option \texttt{-b} means behavioral description, and \texttt{-c} means
compilation only, i.e no simulation.
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) asimut -b -c addaccu

             @        @@@@ @     @                            @@@@@@@@@@ 
             @       @    @@    @@@                           @   @@   @ 
            @@@     @@     @     @                           @    @@    @
            @@@     @@@              @@@ @@ @@@   @@@  @@@@       @@     
           @  @@     @@@@     @@@@    @@@ @@  @@   @@    @@       @@     
           @  @@       @@@@     @@    @@  @@  @@   @@    @@       @@     
          @    @@        @@@    @@    @@  @@  @@   @@    @@       @@     
          @@@@@@@   @      @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@     @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@@    @    @@    @@  @@  @@   @@   @@@       @@     
       @@@@    @@@@ @  @@@@   @@@@@@ @@@@ @@@ @@@   @@@@  @@    @@@@@@   

                                A SIMUlation Tool

                 Alliance CAD System 3.2,         asimut v2.01
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

        Paris, France, Europe, Earth, Solar system, Milky Way, ...
Initializing ...
Searching addaccu ...
BEH : Compiling addaccu.vbe (Behaviour) ...
Making GEX ...
\end{framedverbatim}
\caption{\texttt{Asimut} compiling the behavioral specifications.}
\label{compil}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Behavioral simulation and validation}

A behavioral description without simulation patterns is useless.  
In order to see if the behavior you have just written is functionally 
correct, you must write simulation patterns and use the \texttt{asimut}
simulator function.

Simulation patterns are contained in a plain text file, 
\texttt{addaccu.pat}.
For more informations about the \texttt{pat} format you can read the 
appropriate on-line manual --- \texttt{man~5~pat} --- or read the 
printed documentation.


To get acquainted with \texttt{addaccu.pat}, please issue the following 
command:
\begin{phraseverbatim}
~fred/addaccu %-) vi addaccu.pat
\end{phraseverbatim}

There are several interesting things here.
First, you can recognize the circuit interface again.
Second, you can see that output terminals are now located at the end 
of the interface.
Ordering terminals is very important for \texttt{pat} files.
The order you use to specify terminals greatly influences the way you 
will have to write simulation patterns.
It is important to notice that simulation patterns contain both input 
and output values.
The behavior must be checked using these values.
Comments are prefixed by a \texttt{\#}, and are of much interest here.

Once you have understood the structure of this file, you are able to 
simulate the previous behavioral description.

In order to simulate, please type:
\begin{phraseverbatim}
~fred/addaccu %-) asimut -b addaccu addaccu specifications
\end{phraseverbatim}
to obtain:
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) asimut -b addaccu addaccu specifications

             @        @@@@ @     @                            @@@@@@@@@@ 
             @       @    @@    @@@                           @   @@   @ 
            @@@     @@     @     @                           @    @@    @
            @@@     @@@              @@@ @@ @@@   @@@  @@@@       @@     
           @  @@     @@@@     @@@@    @@@ @@  @@   @@    @@       @@     
           @  @@       @@@@     @@    @@  @@  @@   @@    @@       @@     
          @    @@        @@@    @@    @@  @@  @@   @@    @@       @@     
          @@@@@@@   @      @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@     @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@@    @    @@    @@  @@  @@   @@   @@@       @@     
       @@@@    @@@@ @  @@@@   @@@@@@ @@@@ @@@ @@@   @@@@  @@    @@@@@@   

                                A SIMUlation Tool


                 Alliance CAD System 3.2,         asimut v2.01
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

        Paris, France, Europe, Earth, Solar system, Milky Way, ...
Initializing ...
Searching addaccu ...
BEH : Compiling addaccu.vbe (Behaviour) ...
Making GEX ...

Searching pattern file : addaccu ...
Restoring ...

Linking ...
###----- processing pattern 0 -----###
###----- processing pattern 1 -----###
###----- processing pattern 2 -----###
###----- processing pattern 3 -----###
###----- processing pattern 4 -----###
###----- processing pattern 5 -----###
###----- processing pattern 6 -----###
\end{framedverbatim}
\caption{\texttt{Asimut} checking the behavior with a few functionnal test vectors.}
\label{specs}
\end{figure}
\normalsize

Feel free to add new simulation vectors, as it's a very good practice.
You can also write obviously wrong patterns to see how \texttt{asimut}
behaves when it encounters errors.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Netlist capture and validation}
\label{netlist}

You are now about to capture the logical view of \texttt{addaccu}, 
commonly known as netlist.
The design methodology prevents the designer from building the entire 
netlist in one shot, including pads.
VLSI design is based on hierarchy and incremental approaches.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Netlist capture}

The circuit netlist you have to write will be captured in two steps:
\begin{enumerate}
\item capture of the core netlist;
\item capture of the chip netlist, linking the core with pads.
\end{enumerate}

The core netlist contains standard-cells describing the logical 
functions needed to design the adder, the multiplexer and the
accumulator, and the internal wires.

We do not use a schematic editor for netlist capture, but rather a 
textual approach.
\begin{phraseverbatim}
~fred/addaccu %-) vi core.c
\end{phraseverbatim}

The core netlist is nothing more than a \textbf{C} file containing 
specific function calls for the creation of VLSI objects.
Notice that the include file \texttt{genlib.h} must systematically be 
included at the top of \textbf{genlib}'s files.

The description of a netlist in \textbf{C} is mainly based on the
\texttt{DEF\_LOFIG, LOCON} and \texttt{LOINS} functions.
\texttt{DEF\_LOFIG} defines the name of the resulting netlist view,
\texttt{LOCON} instanciates a new terminal in the currently opened 
figure, and \texttt{LOINS} instanciates pre-existing cells or blocks.
For more informations, please read the on-line manual associated with 
each function.

To compile and run the \textbf{C} file, you must use the \texttt{genlib} 
program.

You must specify the input format of cells that are instanciated in 
the \textbf{genlib}'s code.

Therefore enter the following command:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_OUT_LO vst
\end{phraseverbatim}

These \texttt{setenv} define the input and output formats for the 
specification netlist.

\texttt{vst} stands for structural \textbf{VHDL} description.  
The design methodology assumes that user defined netlists must use 
extension \texttt{vst} as we've already said.
The \texttt{al} format is mostly used for extracted netlist with 
specific informations like capacitances that cannot be coded in \textbf{VHDL}.

At last, you can execute the genlib program:
\begin{phraseverbatim}
~fred/addaccu %-) genlib -v core
\end{phraseverbatim}
to get:
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_OUT_LO vst
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr
~fred/addaccu %-) genlib -v core

             @@@@ @                        @@@@@@         @   @@@      
           @@    @@                          @@          @@@   @@      
          @@      @                          @@           @    @@      
         @@             @@@@@   @@@ @@@      @@                @@ @@   
         @@            @     @   @@@   @     @@        @@@@    @@@  @@ 
         @@     @@@@@ @@     @@  @@    @@    @@          @@    @@    @@
         @@     @ @@  @@@@@@@@@  @@    @@    @@          @@    @@    @@
         @@    @  @@  @@         @@    @@    @@          @@    @@    @@
          @@      @@  @@      @  @@    @@    @@      @   @@    @@    @@
           @@    @@    @@    @@  @@    @@    @@     @    @@    @@@  @@ 
             @@@@        @@@@   @@@@  @@@@ @@@@@@@@@@  @@@@@@ @@@ @@   

                         Procedural Generation Language

                 Alliance CAD System 3.2,           genlib 3.3
                 Copyright (c) 1991-1998,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

Generating the Makefile
Compiling, ...
Current execution environment
MBK_CATA_LIB   : /users/soft5/newlabo/Solaris/cells/sclib
MBK_WORK_LIB   : :
MBK_IN_LO      : vst
MBK_OUT_LO     : vst
MBK_IN_PH      : ap
MBK_OUT_PH     : ap
MBK_CATAL_NAME : CATAL
Executing ...
Removing tmp files ...
\end{framedverbatim}
\caption{Netlist core generation using \texttt{genlib}.}
\label{core}
\end{figure}
\normalsize

You can now look in the current directory for a file named 
\texttt{core.vst}.
This file contains the resulting description of the core.

The \texttt{addaccu.c} file contains the actual chip netlist.  
You can edit it to see how pads are instanciated.

Running the following command:
\begin{phraseverbatim}
~fred/addaccu %-) genlib -v addaccu
\end{phraseverbatim}
produces:
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_OUT_LO vst
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) genlib addaccu

             @@@@ @                        @@@@@@         @   @@@      
           @@    @@                          @@          @@@   @@      
          @@      @                          @@           @    @@      
         @@             @@@@@   @@@ @@@      @@                @@ @@   
         @@            @     @   @@@   @     @@        @@@@    @@@  @@ 
         @@     @@@@@ @@     @@  @@    @@    @@          @@    @@    @@
         @@     @ @@  @@@@@@@@@  @@    @@    @@          @@    @@    @@
         @@    @  @@  @@         @@    @@    @@          @@    @@    @@
          @@      @@  @@      @  @@    @@    @@      @   @@    @@    @@
           @@    @@    @@    @@  @@    @@    @@     @    @@    @@@  @@ 
             @@@@        @@@@   @@@@  @@@@ @@@@@@@@@@  @@@@@@ @@@ @@   

                         Procedural Generation Language

                 Alliance CAD System 3.2,           genlib 3.3
                 Copyright (c) 1991-1998,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr
\end{framedverbatim}
\caption{Core to pad netlist generation using \texttt{genlib}.}
\label{addaccu}
\end{figure}
\normalsize

This creates \texttt{addaccu.vst}, the resulting netlist, in the current 
directory.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulation of the specification netlist}

Once the complete netlist has been captured, we can simulate the 
whole chip with the previous simulation patterns.

You can run asimut by entering the following command: 
\begin{phraseverbatim}
~fred/addaccu %-) asimut addaccu addaccu schema
\end{phraseverbatim}
It produces the output of Figure~\ref{schema}.

The first \texttt{addaccu} stands for \texttt{addaccu.vst}.
The second \texttt{addaccu} stands \texttt{addaccu.pat}, the pattern 
file with input and output values.
\texttt{schema} stands for \texttt{schema.pat}, the generated list of 
patterns.

Because option \texttt{-b} is not set and because \texttt{MBK\_IN\_LO} 
contains \texttt{vst}, \texttt{asimut} simulates the specification 
netlist we have captured with \texttt{genlib}.

Errors during this execution mean that something went wrong between 
your current position in the design flow and the behavioral 
simulation stage.

\small
\begin{figure}[H]\center
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ringxx
~fred/addaccu %-) asimut addaccu addaccu schema
Warning 2 : consistency checks will be disabled

             @        @@@@ @     @                            @@@@@@@@@@ 
             @       @    @@    @@@                           @   @@   @ 
            @@@     @@     @     @                           @    @@    @
            @@@     @@@              @@@ @@ @@@   @@@  @@@@       @@     
           @  @@     @@@@     @@@@    @@@ @@  @@   @@    @@       @@     
           @  @@       @@@@     @@    @@  @@  @@   @@    @@       @@     
          @    @@        @@@    @@    @@  @@  @@   @@    @@       @@     
          @@@@@@@   @      @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@     @@   @@    @@  @@  @@   @@    @@       @@     
         @      @@  @@@    @    @@    @@  @@  @@   @@   @@@       @@     
       @@@@    @@@@ @  @@@@   @@@@@@ @@@@ @@@ @@@   @@@@  @@    @@@@@@   

                                A SIMUlation Tool

                 Alliance CAD System 3.2,         asimut v2.01
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

        Paris, France, Europe, Earth, Solar system, Milky Way, ...
Initializing ...
Searching addaccu ...
Compiling addaccu (Structural) ...

Flattening the root figure ...

Searching a2_y ...
BEH : Compiling a2_y.vbe (Behaviour) ...
Making GEX ...
.
.
.
Searching pi_sp ...
BEH : Compiling pi_sp.vbe (Behaviour) ...
Making GEX ...

Searching pck_sp ...
BEH : Compiling pck_sp.vbe (Behaviour) ...
Making GEX ...

Searching pattern file : addaccu ...
Restoring ...

Linking ...
###----- processing pattern 0 -----###
###----- processing pattern 1 -----###
###----- processing pattern 2 -----###
###----- processing pattern 3 -----###
###----- processing pattern 4 -----###
###----- processing pattern 5 -----###
###----- processing pattern 6 -----###
\end{framedverbatim}
\caption{\texttt{Asimut} checking the netlist description.}
\label{schema}
\end{figure}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core layout generation}
\label{layout}

Incremental design relies on hierarchy.  
Before you design the core to pads netlist, the circuit core must be 
successfully built.
In this example, the layout generation relies on:
\begin{enumerate}
\item standard-cells placement (automatic or manual);
\item automatic routing of standard-cells.
\end{enumerate}

\texttt{scr} is a place and route tool that can produce automatically 
the layout view from a netlist description.

As stated in the previous section, before you run \texttt{scr}, you must 
specify environment variables.
Needless to say that these variables will deal with physical aspects 
of the circuit.


First, you must specify the input layout format you use for the 
standard-cells.
The \textbf{Alliance} distribution only contains \texttt{ap} symbolic 
layout files so you must issue the following command:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_IN_PH ap
\end{phraseverbatim}

This command instructs \texttt{scr} to use the \texttt{ap} cell layout 
format as input.
Remember that the variable \texttt{MBK\_CATA\_LIB} is still set, so 
\textbf{Alliance} tools know where to find cells.

Second, you must accordingly specify the output layout format.  
Again, the format is \texttt{ap}, so:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_PH ap
\end{phraseverbatim}

This command instructs \texttt{scr} to use \texttt{ap} representation of 
cells as an output.

Everything is now ready for the place and route phase.
The command is:
\begin{phraseverbatim}
~fred/addaccu %-) scr -p -r core core
\end{phraseverbatim}

Option \texttt{-p} means automatic placement, and option \texttt{-r} means 
automatic routing.

Once \texttt{scr} has been executed, the core layout is completed.
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv MBK_OUT_PH ap
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr
~fred/addaccu %-) scr -p -r core 

                          @@@@ @      @@@@ @ @@@@@@@    
                         @    @@    @@    @@   @@   @@  
                        @@     @   @@      @   @@    @@ 
                        @@@       @@       @   @@    @@ 
                         @@@@     @@           @@   @@  
                           @@@@   @@           @@@@@    
                             @@@  @@           @@  @@   
                        @      @@ @@           @@   @@  
                        @@     @@  @@      @   @@   @@  
                        @@@    @    @@    @@   @@    @@ 
                        @  @@@@       @@@@   @@@@@   @@@

                              Standard Cell router

                 Alliance CAD System 3.2,              scr 5.2
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

Loading logical view : core
Placing logical view : core
Loading SCP data base ...
Generating initial placement ... 
25 cells 37 nets in 2 rows
Placement in process of treatment :   100%
49% saved in  0.3 s
Saving placement   100%
Checking consistency between logical and physical views
Loading SCR data base ...
Deleting MBK data base ...
Global routing ...
Channel routing ...
|_____Routing Channel : scr_p2 
|_____Routing Channel : scr_p4 
|_____Routing Channel : scr_p6 
Making vertical power and ground wires  
Saving layout : core
\end{framedverbatim}
\caption{Placing and Routing the core netlist with \texttt{scr}.}
\label{scr}
\end{figure}
\normalsize

Note that \texttt{scr} knows how to place and route only cells having a
standard cell topology.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core layout verification}
\label{lv}

Routers may have bugs, and produce shorts or open circuits.
So serious checks must be made on the produced layout.
To check the layout, we use two \textbf{Alliance} tools, \texttt{lynx} and 
\texttt{lvx}.

\texttt{lynx} is the \textbf{Alliance} netlist extractor.
From a physical layout it extracts a netlist representation of the
circuit, in terms of blocks, gates or transistors.  
In our case, we want to extract the core netlist at the gate level.

\texttt{lvx} is the \textbf{Alliance} netlist comparator.
Its main function is to verify that an extracted netlist corresponds 
to the specification netlist.

Hence, the design methodology is quite simple.
We must extract the core \texttt{core.ap} with \texttt{lynx} and check the
resulting netlist with the original \texttt{addaccu.vst}
file using \texttt{lvx}.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Extraction of the core netlist}

Now, back to practice.
You have to extract the layout using \texttt{lynx}.
Remember two things:
\begin{enumerate}
\item \textbf{Alliance} tools deeply rely on appropriate environment 
      variables.
      For instance, you have to specify the format the extracted 
      netlist will be generated with.
\item in the usual design flow, extracted netlist files are written
      in \texttt{al} format.
\end{enumerate}

So you must:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_LO al
\end{phraseverbatim}
to generate a extracted netlist file called \texttt{core.al}.

The actual execution of lynx is quite easy.
Just type:
\begin{phraseverbatim}
~fred/addaccu %-) lynx -v core
\end{phraseverbatim}
and you get your extracted netlist in terms of interconnected 
standard cells.
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv MBK_OUT_LO al
~fred/addaccu %-) setenv RDS_TECHNO_NAME /alliance/etc/cmos_5.rds
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) lynx -v core core

                   @@@@@@                                    
                     @@                                      
                     @@                                      
                     @@        @@@@@ @@@ @@@ @@@    @@@@  @@@
                     @@         @@    @   @@@   @    @@    @ 
                     @@          @@   @   @@    @@    @@  @  
                     @@          @@  @    @@    @@     @@@   
                     @@           @@ @    @@    @@     @@@   
                     @@      @    @@@     @@    @@    @  @@  
                     @@     @      @@     @@    @@   @    @@ 
                   @@@@@@@@@@  @@  @     @@@@  @@@@ @@@  @@@@
                               @@  @                         
                                @@@                          

                                Netlist extractor

                  Alliance CAD System 3.2,            lynx 1.16
                  Copyright (c) 1993-1997,       ASIM/LIP6/UPMC
                  E-mail support: alliance-support@asim.lip6.fr



        ---> Extracts symbolic figure core

                ---> Translate Mbk -> Rds
                ---> Build windows
                <--- 108

                ---> Rectangles    : 894
                ---> Figure size   : (    -50,   -100 )
                                     (  55250,  16600 )

                ---> Cut transistors
                <--- 0
                ---> Build equis
                <--- 37
                ---> Delete windows
                ---> Build signals
                <--- 37
                ---> Build instances
                <--- 29
                ---> Build transistors
                <--- 0
                ---> Save netlist

        <--- done !
\end{framedverbatim}
\caption{Extracting a hierarchical netlist in terms of standard cells with \texttt{lynx}.}
\label{lynx}
\end{figure}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Netlist cross-checking}

Now it's time for netlist verifications.
Since \texttt{lvx} takes two netlist in input, the formats have to be 
specified on the command line.

\begin{phraseverbatim}
~fred/addaccu %-) lvx vst al core core
\end{phraseverbatim}

\texttt{lvx} works somewhat differently from other tools.
Its two former arguments are the formats of the first netlist, here
\texttt{vst} (for the original netlist)  and \texttt{al} (for the extracted 
netlist).
The two following arguments are the names of the netlist.
We have done our best to make these names identical.
Once again, remember that specification files are postfixed with
\texttt{vst} and extracted files with \texttt{al}.
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) lvx vst al core core -f

                       @@@@@@      @@@@    @@@ @@@@   @@@@
                         @@         @@      @   @@     @  
                         @@         @@      @    @@   @   
                         @@          @@    @      @@ @    
                         @@          @@    @       @@     
                         @@           @@  @        @@     
                         @@           @@  @        @@@    
                         @@            @@@        @  @@   
                         @@      @     @@@       @    @@  
                         @@     @       @       @      @@ 
                       @@@@@@@@@@       @      @@@    @@@@

                             Gate Netlist Comparator

                  Alliance CAD System 3.2,             lvx 2.23
                  Copyright (c) 1992-1997,       ASIM/LIP6/UPMC
                  E-mail support: alliance-support@asim.lip6.fr

***** Loading and flattening core (vst)...

***** Loading and flattening core (al)...

***** Compare Terminals ..............
***** O.K.      (0 sec)

***** Compare Instances ..........
***** O.K.      (0 sec)

***** Compare Connections ............
***** O.K.      (0 sec)

===== Terminals .......... 16    
===== Instances .......... 25    
===== Connectors ......... 150   

***** Netlists are Identical. *****     (0 sec)
\end{framedverbatim}
\caption{Doing the specification netlist versus extracted netlist
         compaison with \texttt{lvx}.}
\label{lvx}
\end{figure}
\normalsize

As a result, you now have a correct \texttt{al} file for the circuit's 
core.
Its name is \texttt{core.al}.  
This file may now be simulated with \texttt{asimut}, but this is only 
for cross checking.  

Execution environment is set by issuing:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_IN_LO al
\end{phraseverbatim}
because we want to use the extracted \texttt{core.al} file as input to 
\texttt{asimut}.

Then you can run asimut by entering the following command:
\begin{phraseverbatim}
~fred/addaccu %-) asimut core addaccu result
\end{phraseverbatim}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Core to pads routing}
\label{pads}

Having built and checked the core layout, you can run the 
core-to-pads router.
Its function is to locate pads appropriately around the core and to 
create wiring segments between pads and chip terminals.

Before we set up the execution environment, take a look at the
\texttt{addaccu.rin} file.
This file instructs \texttt{ring}, the core to pads router, to place pads
according to designer's wishes.
It also instructs \texttt{ring} to use segments with reasonable width 
for power routing.

The syntax of this file is quite simple.
The names mentioned here are pads' instance names.

Run:
\begin{phraseverbatim}
~fred/addaccu %-) ring addaccu addaccu
\end{phraseverbatim}

\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO vst
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv MBK_OUT_PH ap
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) ring addaccu addaccu

                   @@@@@@@        @                  @@@@ @  
                     @@   @@     @@@               @@    @@  
                     @@    @@     @               @@      @  
                     @@    @@         @@@ @@@    @@          
                     @@   @@   @@@@    @@@   @   @@          
                     @@@@@       @@    @@    @@  @@     @@@@@
                     @@  @@      @@    @@    @@  @@     @ @@ 
                     @@   @@     @@    @@    @@  @@    @  @@ 
                     @@   @@     @@    @@    @@   @@      @@ 
                     @@    @@    @@    @@    @@    @@    @@  
                   @@@@@   @@@ @@@@@@ @@@@  @@@@     @@@@    

                                 PAD ring router

                 Alliance CAD System 3.2,             ring 2.9
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

        o reading netlists, layout views of core and pads.
Warning 2 : consistency checks will be disabled
        o reading file of parameters, including the placements of pads.
        o making equipotential list.
        o making the first placement of pads.
        o filling data internal structures.
        o reading the connectors positions of the core.
        o computing the best placement of the pads.
        o reading the connectors positions of the pads.
        o routing deportation of connectors.
        o routing supply tracks.
        o routing equipotentials.
        o compressing channels.
        o saving in MBK data structure.
lucky, no error.
\end{framedverbatim}
\caption{\texttt{Ring} routes the core to pad netlist.}
\label{ring}
\end{figure}
\normalsize

Like for the core, the core to pad routing must be verified.
Using the same approach leads to:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_LO al
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) lynx -v addaccu
~fred/addaccu %-) lvx vst al addaccu
\end{phraseverbatim}

It is possible to check both core a core to pad routing at once also:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_OUT_LO al
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) lynx -v -f addaccu
~fred/addaccu %-) lvx vst al addaccu -f
\end{phraseverbatim}

Here the \texttt{-f} option indicate the tools to express the netlist in 
terms of leaf cells --- either pads or standard cells ---.
Obtaining a transistor netlist from the layout is possible using the
\texttt{-t} option of \texttt{lynx}, but this is more time and memory
consuming, and fairly useless as we rely on correct cells.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Chip layout visualization}
\label{graal}

At that point, you are able to see the actual layout by executing the 
symbolic layout editor \texttt{graal}.
You can run the editor by issuing the following command:
\begin{phraseverbatim}
~fred/addaccu %-) graal -l addaccu
\end{phraseverbatim}

Now, the screen should be filled with the \texttt{graal} window, and 
should contain the whole layout.
The graphical interface of \texttt{graal} is meant to be self 
explanatory.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functional abstraction}
\label{fa}

\texttt{yagle}, a functional asbtractor that extracts a behavior from a 
transistor netlist can relieve the designer from many headaches.
From a transistor netlist,\texttt{yagle} finally outputs a 
\textbf{VHDL} file that can be simulated.

The command is: 
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_IN_LO al
~fred/addaccu %-) yagle -i -v addaccu
\end{phraseverbatim}
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_LO al
~fred/addaccu %-) yagle addaccue -i -v

                                               @@@@            
                                                 @@            
                                                 @@            
                  @@@@@ @@@   @@@@      @@@@@@   @@     @@@@@  
                   @@    @   @@   @    @@  @@    @@    @     @ 
                    @@   @   @@   @@   @   @@    @@   @@     @@
                    @@  @      @@@@@   @   @     @@   @@@@@@@@@
                     @@ @    @@   @@    @@@      @@   @@       
                     @@@    @@    @@   @@        @@   @@      @
                      @@    @@   @@@   @@@@@@    @@    @@    @@
                  @@  @      @@@@  @@ @@   @@@ @@@@@@    @@@@  
                  @@  @                @     @                 
                   @@@                  @@@@@                  

                        Yet Another Gate Level Extractor

                 Alliance CAD System 3.2,           yagle 2.01
                 Copyright (c) 1994-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

[YAG MES] Reading file 'addaccue.inf'
[YAG MES] Loading the figure addaccue              00m00s  u:00m00.0  s:00m00.0
[YAG MES] Transistor netlist checking              00m00s  u:00m00.0  s:00m00.0
[YAG MES] Extracting CMOS duals                    00m00s  u:00m00.0  s:00m00.0
[YAG MES] Extracting bleeders                      00m00s  u:00m00.0  s:00m00.0
[YAG MES] Making gates                             00m00s  u:00m00.0  s:00m00.0
[YAG MES] Latches detection                        00m00s  u:00m00.0  s:00m00.0
[YAG MES] Making cells                             00m00s  u:00m00.0  s:00m00.0
[YAG MES] External connector verification          00m00s  u:00m00.0  s:00m00.0
[YAG MES] Checking the yagle figure                00m00s  u:00m00.0  s:00m00.0
[YAG MES] Building the behavioural figure          00m00s  u:00m00.0  s:00m00.0
TOTAL DISASSEMBLY TIME                             00m00s  u:00m00.0  s:00m00.0
------------------------------------------------------------
[YAG MES] Erasing the transistor netlist
[YAG MES] Generating the VHDL Data Flow
[YAG MES] Execution COMPLETED 
------------------------------------------------------------
[YAG WAR 04] 80 transistors are always off
[YAG WAR 07] 80 transistors are not used 
[YAG WAR 09] 8 latches detected
See file 'addaccue.rep' for more information
\end{framedverbatim}
\caption{\texttt{Desb} abstract the extracted netlist into boolean
         equations.}
\label{yagle}
\end{figure}
\normalsize

Then, you can simulate the resulting behavior file by issuing:
\begin{phraseverbatim}
~fred/addaccu %-) asimut -b addaccu addaccu result
\end{phraseverbatim}

Simulation of extracted behavior with asimut is not the only mean to 
see if the chip is correct.
The extracted behavior can also be used for formal proof.

In \textbf{Alliance}, formal proof is the ultimate way to validate your 
circuit.

Before you can use \texttt{proof}, the formal prover, you must get
acquainted with some specific concepts of the formal proof theory.

If you look at the extracted behavior, \texttt{chip.vbe}, you can notice 
that \texttt{yagle} has found four memorizing elements, specified as
\texttt{reg\_bit register}.
In the formal proof, these four elements must match the four 
edge-triggered latches of the former behavioral specification, 
because \texttt{proof} can only compare combinatorial logic between 
external connectors and/or sequential elements.  

If you examine the current directory, you will find a file called 
\texttt{addaccu.inf}.

This file contains specific informations for \texttt{yagle}.
It instructs \texttt{yagle} to rename the internal node name of every 
latch \textit{core.l*} by its corresponding name in the first behavior 
file.
In the \texttt{cells/scr} directory you can see that the name of the
internal node of the used latch, \texttt{ms\_y.vbe}, is \textit{dff\_s}.

The equivalent name in \texttt{addaccu.vbe} is \textit{reg}.

When you run \texttt{yagle} with option \texttt{-i}, the program searches 
for the file \texttt{chip.inf}, builds the gate netlist and replaces the 
node names by their equivalent names in the behavior file, in order 
to make \texttt{proof} work.

Then, you can run \texttt{proof}, the formal prover:
\begin{phraseverbatim}
~fred/addaccu %-) proof -d -p addaccu addaccue
\end{phraseverbatim}
\small
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) proof -d addaccue addaccu

                @@@@@@@                                     @@@ 
                  @@   @@                                  @  @@
                  @@    @@                                @@  @@
                  @@    @@ @@@ @@@     @@@       @@@      @@    
                  @@   @@   @@@  @@  @@   @@   @@   @@  @@@@@@@@
                  @@@@@     @@   @@ @@     @@ @@     @@   @@    
                  @@        @@      @@     @@ @@     @@   @@    
                  @@        @@      @@     @@ @@     @@   @@    
                  @@        @@      @@     @@ @@     @@   @@    
                  @@        @@       @@   @@   @@   @@    @@    
                @@@@@@     @@@@        @@@       @@@    @@@@@@  

                                  Formal Proof

                 Alliance CAD System 3.2,          proof 3.158
                 Copyright (c) 90-97,           ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr

================================  Environment  ================================
MBK_WORK_LIB            = .
MBK_CATA_LIB            = /labo/cells/grog
=======================  Files, Options and Parameters  =======================
First VHDL file         = addaccue.vbe
Second VHDL file        = addaccu.vbe
The auxiliary signals are erased
Errors are displayed
===============================================================================

Compiling 'addaccue' ...
Compiling 'addaccu' ...

Running abl ordonnancer on addaccue
........

Running Abl2Bdd on addaccue
---> final number of nodes = 664(404)

Running Abl2Bdd on addaccu
--------------------------------------------------------------------------------
             Formal proof with Ordered Binary Decision Diagrams between   

             './addaccue'  and  './addaccu'
--------------------------------------------------------------------------------
==============================  PRIMARY OUTPUT  ===============================
=============================  AUXILIARY SIGNAL  ==============================
==============================  REGISTER SIGNAL  ==============================
===============================  EXTERNAL BUS =================================
================================ INTERNAL BUS =================================

                            Formal Proof : OK

pppppppppppppppppppppppprrrrrrrrrrrrooooooooooooooooooooooooooooofffffffffffffff
--------------------------------------------------------------------------------
\end{framedverbatim}
\caption{Doing a formal proof between the abstracted behavior and the
         specifications using \texttt{proof}.}
\label{proof}
\end{figure}
\normalsize

Option \texttt{-d} displays the logical functions that do not match, and 
the \texttt{-p} option tells \texttt{proof} to ignore the internal polarity
of the flip-flops: we described our behavioral with a register 
%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Further verifications}
\label{verif}

The last verification concerns design rules.  
Before the chip can actually be targetted on a process, a symbolic 
design rule check --- DRC --- must be performed.

In \textbf{Alliance}, the design rule checker is \texttt{druc}.

You just have to type:
\begin{phraseverbatim}
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv RDS_TECHNO_NAME /alliance/etc/cmos_5.rds
~fred/addaccu %-) druc addaccu
\end{phraseverbatim}

The file pointed to by the \texttt{RDS\_TECHNO\_NAME} environement variable
contains many technological information including the desription of 
the design rules.
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv RDS_OUT cif 
~fred/addaccu %-) setenv RDS_TECHNO_NAME /alliance/etc/cmos_5.rds
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) druc addaccu

                  @@@@@@@     @@@@@@@                    @@@@ @
                    @@   @@     @@   @@                @@    @@
                    @@    @@    @@    @@              @@      @
                    @@     @@   @@    @@  @@@  @@@@  @@       @
                    @@     @@   @@   @@    @@    @@  @@        
                    @@     @@   @@@@@      @@    @@  @@        
                    @@     @@   @@  @@     @@    @@  @@        
                    @@     @@   @@   @@    @@    @@  @@        
                    @@    @@    @@   @@    @@    @@   @@      @
                    @@   @@     @@    @@   @@   @@@    @@    @@
                  @@@@@@@     @@@@@   @@@   @@@@  @@     @@@@  

                               Design Rule Checker

                  Alliance CAD System 3.2,            druc 3.00
                  Copyright (c) 1993-1997,       ASIM/LIP6/UPMC
                  E-mail support: alliance-support@asim.lip6.fr

Flatten DRC on: addaccu
Delete MBK figure : addaccu
Load Flatten Rules : /usr/local/cad/alliance/etc/cmos_7.rds

Unify : addaccu

Create Ring : addaccu_rng
Merge Errorfiles: 

Merge Error Instances:
instructionCourante : 50
End DRC on: addaccu
Saving the Error file figure
Done
  0

File: addaccu.drc is empty: no errors detected.
\end{framedverbatim}
\caption{Symbolic design rule checking using \texttt{druc}.}
\label{druc}
\end{figure}

This layout level verification has been optimized for speed.
So it is fast, even on large circuits, but requires quite a few megs
then.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Symbolic to real technology translation}
\label{sr}

The purpose of \textbf{Alliance} symbolic layout approach is to allow 
the designs to be targetted on several technologies.
The whole chip is conceived with symbolic cells.

In order to send the chip to a specified foundry, the designer must 
perform the symbolic to real conversion.
This stage is the last stage of the design methodology.

The only things you have to specify is the target technology and some 
environment variables.

The only target technology available in the distribution is
\texttt{prol10}, a fake 1.0 process.
You can choose it by setting the \texttt{RDS\_TECHNO\_NAME} environment 
variable.
\begin{phraseverbatim}
~fred/addaccu %-)setenv RDS_TECHNO_NAME /alliance/etc/prol10.rds
\end{phraseverbatim}

You also have to specify the format of the output file that will
represent the foundry layout.
\textbf{Alliance} provides two distinct formats: \texttt{gds} and \texttt{cif}.
\begin{phraseverbatim}
~fred/addaccu %-) setenv RDS_OUT cif
\end{phraseverbatim}

This command instructs the converter to output the chip in the 
Caltech Intermediat Form.
This form is an \texttt{ascii} format, that can include connectors,
whereas \texttt{gds} is binary and doesn't include connectors.

A tricky thing is that the \textit{pad} part of the symbolic IO pads must 
be replaced by its "real" equivalent.
This is indeed the only technology dependant part of a circuit
designed with our symbolic approach.

So you also have to set the \texttt{RDS\_IN} environment variable, to
indicate the format of the substitution pad.
\begin{phraseverbatim}
~fred/addaccu %-) setenv RDS_IN cif
\end{phraseverbatim}

At last, you run the symbolic to real converter, \texttt{s2r}.
\begin{phraseverbatim}
~fred/addaccu %-) s2r -cv addaccu
\end{phraseverbatim}

Your chip is now ready for the foundry that provides the prol10 
technology.
\begin{figure}[H]\center\leavevmode
\begin{framedverbatim}
~fred/addaccu %-) setenv MBK_IN_PH ap
~fred/addaccu %-) setenv MBK_CATA_LIB /alliance/cells/scr:/alliance/cells/ring
~fred/addaccu %-) setenv RDS_TECHNO_NAME /alliance/etc/prol10.rds
~fred/addaccu %-) setenv RDS_OUT cif 
~fred/addaccu %-) setenv RDS_IN cif
~fred/addaccu %-) s2r -v addaccu

                                      @@@@           
                                     @   @@          
                                    @@    @@         
                            @@@@@@  @@@   @@ @@@ @@@ 
                           @@    @   @   @@   @@@  @@
                           @@@           @    @@   @@
                            @@@@        @     @@     
                              @@@@     @      @@     
                           @    @@@   @    @  @@     
                           @@    @@  @@@@@@   @@     
                           @ @@@@@  @@@@@@@  @@@@    

                        Symbolic to Real layout converter

                 Alliance CAD System 3.2,              s2r 3.6
                 Copyright (c) 1991-1997,       ASIM/LIP6/UPMC
                 E-mail support: alliance-support@asim.lip6.fr


        o loading technology file : /usr/local/cad/alliance/etc/prol10_7.rds
        o loading all level of symbolic layout : addaccu
        o removing symbolic data structure 
        o layout post-treating with connectors, with scotchs.
        --> post-treating model palo_sp
            rectangle merging : 
            . RDS_NWELL .................................
            . RDS_NIMP .................................
            . RDS_PIMP .................................
            . RDS_ACTIV .................................
            . RDS_POLY .................................
            . RDS_ALU1 .................................
            . RDS_ALU2 .................................
            .
            .
            .
        o replacing black boxes
        --> replace cell padreal 
        o saving addaccu.cif
        o memory allocation informations
        --> required rectangles = 7318  really allocated = 7
        --> required scotchs = 3  really created = 3
        --> Number of allocated bytes: 341231
\end{framedverbatim}
\caption{Translating the symbolic layout into process layout with \texttt{s2r}.}
\label{s2r}
\end{figure}
\normalsize

%%%%%%%%%%%%%%%%%%%%%%%%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}

If you actually arrived here doing all the previous steps,
congratulation!

You can see an automatic replay of this tutorial by
executing the \texttt{Makefile} in the current directory by issuing the
command:
\begin{phraseverbatim}
~fred/addaccu %-) make
\end{phraseverbatim}
Note that the \texttt{Makefile} uses Bourne-shell commands.

If you plan to design a chip with \textbf{Alliance}, it is a good idea to
use \texttt{Makefile}s to ensure the consistency between the design and
verifications of the differents views and hierarchies, but this is
another story.

If anything went wrong or if you have any question, you can contact
us by sending a mail to the support team of \textbf{Alliance}, located 
at \texttt{alliance-support@lip6.fr}.
\end{document}
