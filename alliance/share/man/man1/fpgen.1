.\"   $Id: fpgen.1,v 1.1 1999/05/31 17:30:13 alliance Exp $
.TH FPGEN 1 "October 1, 1997" "ASIM/LIP6" "FITPATH Macro-Functions"
.so man1/alc_origin.1
.SH NAME
\fBfpgen\fP - Procedural language for Data-Path synthesis based upon C.
.SH SYNOPSIS
.ft  B
fpgen [--no-exec] [--keep-exec] [-v] <\fISourceFile\fP> [-e <\fIArgs\fP>]
.ft  R
.SH DESCRIPTION
.ta 4n
	\fBfpgen\fP is a set of \fBC\fP functions dedicated to \fIdata-path\fP
synthesis. It provide a large set of vectorized operators, in the
following, the \fBC\fP functions which generates such \fIdata-path\fP
components are called \fIMacro-functions\fP. \fBfpgen\fP create a
hierarchical \fINetList\fP that can be given to the \fIdata-path\fP place
and route tool \fBdpr(1)\fP.
.br
.SH MISCELLANEOUS FUNCTIONS
.ta  19n
.in +19n
.ti -19n
\fBDP_DEFLOFIG()\fR	Open a new logical figure and set \fBdata-path\fR
context to its default configuration.
.ti -19n
\fBDP_SAVLOFIG()\fR	Close and save on disk the current logical figure.
.ti -19n
\fBDP_TRACE()\fP	Enable/disable trace mode.
.ti -19n
\fBDP_LOCON()\fR	Define a connector.
.ti -19n
\fBDP_IMPORT()\fP	Instanciate a data-path compatible component.
.in -19n
.SH MACRO-FUNCTIONS
.ta 4n 
	The behavior of all the \fBmacro-functions\fP can be described by
the four following steps :

.ta +6n
\fBI)\fP	Reading arguments and performing some checks.
.br

\fBII)\fP	Looking for a previously generated model with the same
set of parameters as actually required, in an internal table.
If the model has already been generated, jump to step \fBIV)\fP.
.br

\fBIII)\fP	At this point, the model is created by a call
to the generator associated to this \fBmacro-function\fP. Then the
new model is stored in the internal table.
.br
	Notice that the model name is not accessible by the
designer. The \fBmacro-function\fP encode the parameters and the
context in order to build this name.
.br

\fBIV)\fP	A new instance of the model is added to the current
working figure.
.br
	As in \fBGENLIB(1)\fP each of the signals given
as arguments are connected to an instance connector. The 
connectors are implicitly matched from the order of the signal
on the list. The supply connectors are automatically added
by the \fBmacro-function\fP, thus they have not to appear in the
call.
.br

	In all the macro-function descriptions, it is shown that
connectors have two different types. The \fIData\fR (noted \fBDATA\fP) and the
\fIControl\fR (noted \fBCTRL\fP) types. 
.br
.ta  2n +9n +2n
.in +13n
.ti -13n
-	\fBDATA\fP	:	Corresponds to a virtual connector used in horizontal
connections in \fIfplib\fP cells to interconnect \fBdata\fR signals.
.ti -13n
-	\fBCTRL\fP	:	Corresponds to a North or South connector generally used to
introduce vertical \fBcontrol\fR signals in \fIfplib\fP cells.
.ta 4n
.in -13n

All the \fBC\fP macro-function calls have the followings common arguments :
.br
.ta   2n +9n +2n
.in +13n
.ti -13n
-	\fIInstName\fP	:	Name of the new instance in the operator.
.br
.ti -13n
-	\fIWidth\fP	:	Width of the operator bus, in bits.
.br
.ti -13n
-	\fISlice\fP	:	Bottom slice of the operator(i.e. the slice where the LSB will be set).
.br
	All view of the \fBMacro-Function\fP are stored in the directory given
by the \fBFPGEN_LIB\fP environement variable. The associated \fBCATAL\fP
file is automatically updated
.SS MODEL NAMES
.ta +4n +8m
	\fBfpgen\fP generate itself the operator model names and give them
special meanings. So, designers must avoid to use same names. The
reserved names are listed below (using regular expression syntax) :
.br

		\fB[a-z0-9]*_[0-9x]*[lm]_cl\fP
.br
		\fB[a-z0-9]*_[0-9x]*[lm]_bk\fP
.br

	At the opposite, when the designer wants to create a custom operator,
with \fBGenLib\fP or logical synthetizer \fBscmap(1)\fP he must gave to
his operator model name the suffix \fB"_us"\fP.
.SS AVALAIBLE MACRO-FUNCTIONS
.ta +21n
.in +21n
.ti -21n
Booleans:
.ti -21n 
\fBDP_INV()\fR	Inverter.
.ti -21n 
\fBDP_BUFF()\fR	Buffer.
.ti -21n 
\fBDP_AND2()\fR	Logical \fBand\fR, two inputs.
.ti -21n 
\fBDP_NAND2()\fR	Logical \fBand\fR, two inputs, complemented output.
.ti -21n 
\fBDP_AND3()\fR	Logical \fBand\fR, three inputs.
.ti -21n 
\fBDP_NAND3()\fR	Logical \fBand\fR, three inputs, complemented output.
.ti -21n 
\fBDP_OR2()\fR	Logical \fBor\fR, two inputs.
.ti -21n 
\fBDP_NOR2()\fR	Logical \fBor\fR, two inputs, complemented output.
.ti -21n 
\fBDP_OR3()\fR	Logical \fBor\fR, three inputs.
.ti -21n 
\fBDP_NOR3()\fR	Logical \fBor\fR, three inputs, complemented output.
.ti -21n 
\fBDP_XOR2()\fR	Logical \fBexclusive or\fR, two inputs.
.ti -21n 
\fBDP_XNOR2()\fR	Logical \fBexclusive or\fR, two inputs, complemented output.

.ti -21n
Masks :
.ti -21n
\fBDP_NAND2MASK()\fR	Logical \fBand\fR mask, complemented output.
.ti -21n
\fBDP_NOR2MASK()\fR	Logical \fBor\fR mask, complemented output.
.ti -21n
\fBDP_XNOR2MASK()\fR	Logical \fBexclusive or\fR mask, complemented output.

.ti -21n
Multiplexers :
.ti -21n 
\fBDP_NMUX2CS()\fR	Multiplexer, 2 inputs, complemented output.
.ti -21n 
\fBDP_MUX2CS()\fR	Multiplexer, 2 inputs.
.ti -21n 
\fBDP_MUX3Cs()\fR	Multiplexer, 3 inputs.
.ti -21n 
\fBDP_MUX4Cs()\fR	Multiplexer, 4 inputs.
.ti -21n 
\fBDP_MUX5Cs()\fR	Multiplexer, 5 inputs.
.\".ti -21n 
.ti -21n
\fBDP_NBUSE()\fR	Tristate, complemented output.
.ti -21n
\fBDP_BUSE()\fR	Tristate.

.ti -21n
Arithmetic:
.ti -21n
\fBDP_ADD2F\fR	fast adder, two operands.
.ti -21n
\fBDP_ADSB2F()\fR	Controlable adder substractor, 2 operands (need \fBrsa\fP
dedicated leaf cell library).
.ti -21n
\fBDP_SHIFT()\fR	Barrel shifter (need \fBbsg\fP dedicated leaf cells
library).
.ti -21n
\fBDP_MULT()\fR	Unpipelined array multiplier (need \fBamg\fP
dedicated leaf cell library).
.ti -21n
\fBDP_MULTP()\fR	Pipelined array multiplier (need \fBamg\fP
dedicated leaf cell library).

.ti -21n
Miscellaneous:
.ti -21n
\fBDP_NUL()\fR	Zero detect.
.ti -21n
\fBDP_CONST()\fR	Constant generator.

.bp
.ti -21n
Registers:
.ti -21n
\fBDP_PDFF()\fR	D flip-flop with write enable.
.ti -21n
\fBDP_PDFFR()\fR	D flip-flop with write enable and reset.
.ti -21n
\fBDP_PDFFT()\fR	D flip-flop with write enable and scan.
.ti -21n
\fBDP_PDFFRT()\fR	D flip-flop with write enable, scan and reset.
.ti -21n
\fBDP_RGF1CC()\fR	D Register file, one read bus.
.ti -21n
\fBDP_RGF1C0()\fR	D Register file, one read bus, \fBR0 <= 0\fP.
.ti -21n
\fBDP_RGF2CC()\fR	D Register file, two read bus.
.ti -21n
\fBDP_RGF2C0()\fR	D Register file, two read bus, \fBR0 <= 0\fP.
.br
(need \fBrfg\fP dedicated leaf cells
library).
.SH OPTIONS
.in +12n
.ta +12n
.ti -12n
\fB-v\fP	Verbose mode. \fBfpgen\fP will show one message per processing
step.

.ti -12n
\fB--keep-exec\fP	Do not erase the executable after run.

.ti -12n
\fB--no-exec\fP	Skip the execution step.

.ti -12n
\fISourceFile\fP	Name of the file containing the \fBfpgen\fP specific
\fBC\fP source progam.

.ti -12n
\fB-e <\fIArgs\fB>\fR	All arguments following \fB-e\fP are passed to the executable.
.in -12n
.SH ENVIRONMENT VARIABLES
.ta +20n
.in +20n
.ti -20n
\fBMBK_CATA_LIB\fP	Contain the list of directories path holding the
leaf cells libraries. All \fImacro-funcions\fP uses the \fBfplib(5)\fP
library, and a few others need additionnal one.
.br
.ti -20n
\fBFPGEN_LIB\fP	The path were \fBFpGen\fP will store all the generated
models, and their associated \fBCATAL\fP. If not set \fBMBK_WORK_LIB\fP
will be used. Notice that this library path must also be part of the
\fBMBK_CATA_LIB\fP list.
.br
.SH SEE ALSO
.ft B
genlib(1)
,
fpgen(1), dpr(1), genlib(1), mbk(1),
DP_DEFLOFIG(3), DP_SAVLOFIG(3), DP_LOCON(3), DP_IMPORT(3),
DP_INV(3), DP_BUSE(3), DP_AND2(3), DP_NAND2(3), DP_AND3(3), DP_NAND3(3),
DP_OR2(3), DP_NOR2(3), DP_OR3(3), DP_NOR3(3), DP_XOR2(3), DP_XNOR2(3),
DP_NAND2MASK(3), DP_NOR2MASK(3), DP_XNOR2MASK(3), DP_CONST(3),
DP_NMUX2CS(3), DP_MUX2CS(3), DP_MUX3CS(3), DP_MUX4CS(3), DP_MUX5CS(3),
DP_BUSE(3), DP_NBUSE(3), DP_ADD2F(3), DP_ADSB2F(3),
DP_SHIFT(3), DP_MULT(3), DP_MULTP(3), DP_NUL(3),
DP_PDFF(3), DP_PDFFR(3), DP_PDFFT(3), DP_PDFFRT(3),
DP_RFG1C0(3), DP_RFG1CC(3), DP_RFG2C0(3), DP_RFG2CC(3)
,


.so man1/alc_bug_report.1

