.\"   $Id: equalVarExpr.3,v 1.1 1999/05/31 17:30:20 alliance Exp $
.\" @(#)equalVarExpr.2 7.01 92/08/22 ; Labo masi cao-vlsi; Author : Luc Burgun
.TH EQUALVAREXPR 3 "October 1, 1997" "ASIM/LIP6" "ABL functions"
.so man1/alc_origin.1
.SH NAME
\fBequalVarExpr\fP \- checks that two expressions are syntactically equal 
.SH SYNOPSYS
.nf
#include "logmmm.h"
int equalVarExpr(expr1,expr2)
chain_list *expr1,*expr2;
.fi
.SH PARAMETERS
.TP 20
\fIexpr1\fP
first expression
.TP 20
\fIexpr1\fP
second expression
.SH DESCRIPTION
\fBequalVarExpr()\fP compares its arguments and returns 0 if \fIexpr1\fP and \fIexpr2\fP are syntactically different, in any other case, 1 is returned. Contrary to the \fBequalExpr()\fP function, atomic expressions aren't compared.
.SH EXAMPLE
.nf
#include "mutnnn.h"		/* mbk utilities */
#include "logmmm.h"
chain_list *expr1,*expr2; 

	/* Let's suppose that
		expr1 = (OR (AND a b) (XOR c d))
		expr1 = (OR (AND f b) (XOR a t))
	*/
printf("%d",equalVarExpr(expr1,expr2));
/* it will display
1
*/
freeExpr(expr2);
expr2 = createExpr(OR);
addQExpr(expr2,createAtom("b"));
addQExpr(expr2,createAtom("a"));
addQExpr(expr2,createAtom("c"));
printf("%d",equalVarExpr(expr1,expr2));
/* it will display
0
*/
freeExpr(expr1);
freeExpr(expr2);
.fi
.SH SEE ALSO
.BR log (1),
.BR abl (1),
.BR equalExpr (3),
.BR PMExpr (3),
.BR searchExpr (3),
.BR searchOperExpr (3),
.BR lengthExpr (3),
.BR profExpr (3),
.BR numberAtomExpr (3).

.so man1/alc_bug_report.1

