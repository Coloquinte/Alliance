.\" $Id: sxlib.5,v 1.5 1999/09/28 07:21:23 franck Exp $
.\" @(#)Labo.l 0.0 92/09/24 UPMC; Author: Franck Wajsburt
.TH SXLIB 5 "September 16, 1999" "ASIM/LIP6" "CAO\-VLSI Reference Manual"
.SH NAME
.B sxlib - a portable CMOS Standard Cell Library
.so man1/alc_origin.1

.SH DESCRIPTION

\fBsxlib\fP library contains standard cells that have been developed at
UPMC-ASIM/LIP6. This manual gives the list of available cells, with their
behavior, width, maximum delay and input fan-in. This manual gives also 
few thumb rules to help the user to well use the cells. The given delais
are the maximum (that means worst case for a generic .35 micron process). 
More precise delais can be found in ALLIANCE VHDL behavior files (.vbe file).
Cell-name is built that way <behavior>_<output drive> 
(see explanations below).

.nf
Four files are attached to each cell:-
- ALLIANCE Layout ............... cell-name.ap
- ALLIANCE Transistor net-list .. cell-name.al
- ALLIANCE VHDL behavior ........ cell-name.vbe
- Compiled HILO behavior ........ 0000000xx.dat

And few files more:-
- CATAL ......................... ALLIANCE catalog file
- sxlib.cct ..................... Cell definition for HILO CAD tools
- CIRCUIT.idx ................... HILO catalog file
- sxlib.lib ..................... Cell definition for Synopsys CAD tools
- sxlib.db ...................... Compiled cell definition for Synopsys
- sxlib.sdb ..................... Icon definition for Synopys

.fi

.SH PHYSICAL OUTLINE

\fBsxlib\fP uses the symbolic layout promoted by Alliance in order to
provide process independence. All dimensions are in lambda units. The
mapping to a specific process CIF or GDS2 layout must be performed by the
\fBs2r\fP tool (symbolic to real), which uses a value for the lambda
(e.g. 1 lambda=0.3um).
.nf

       _________________
   50 |       VDD       |
   45 |_________________|     x : place of virtual connector.
   40 |           x     |
   35 |        x  x     |         they are named : name_<y>
   30 |  x     x        |
   25 |  x     x        |         for example : i0_20
   20 |  x              |                       i0_25
   15 |           x     |                       i0_30
   10 |_________________|
    5 |       VSS       |
    0 |_________________|
      0  5 10 15 20 25 30

.fi
All cells are 50 lambdas high and \fBN\fP times 5 lambdas wide, where
\fBN\fP is the number of pitches. That is the only physical information
given in the cell list below.  Power supplies are in horizontal ALU1 and
are 6 lambdas wide.  Connectors are inside the cells, placed on a 5x5 grid.
Half layout design rules are a warranty for any layer on any face, except
for the power supply and NWELL.  Cells can be abutted in all directions
whenever the supply is well connected and connectors are always placed on
the 5x5 grid.

.SH DELAY MODEL

Cells have been extracted and simulated by using a generic 0.35um process
in order to give realistic values for the delays and capacitances.  We
chose to give only the worst delay for each output signal, though it is not
very realistic.  (since delay depends on each input, an input can be easily
up to twice faster than another). However, we just wanted to give an idea
of the relative delay.

Furthermore, we added 0.6ns to each output delay in order to take into
account the delay due to the signal commutation. We have supposed the
output drives the maximum capacitance. This capacitance have been computed
as follow. We considered that a good slope signal for this process was
0.8ns.  Then we searched for the capacitance required to obtain the same
input and output slope (0.8ns) for the smaller inverter (inv_x1). That was
125fF. We simulated the same inverter without output capacitance. The delay
difference was about 0.6ns. This result is not exactly the same for all
cells, but 0.6ns is a good approximation.

The given delay is then a worst case (70degree, 2.7Volt, slow process,
worst input), an idea of the typical delay can be obtain by dividing worst
delay by 1.5, and best delay by dividing by 2.  More detailed data can be
found in GENERIC data included in the VHDL files (.vbe). Examples can be
found at the end of this manual.

.SH OUTPUT DRIVE

The output drive of a cell gives an information on the faculty for the cell
to drive a big capacitance. This faculty depends on the rising and falling
output resistance. The smaller the resistance, the bigger can be the
capacitance.  Minimum drive is \fBx1\fP. This corresponds to the smallest
available inverter (inv_x1). \fBx2\fP means the cell is equivalent (from
the driving point of view) at two smaller inverters in parallel, and so
on.

The maximum output drive is \fBx8\fP. It is limited because of the maximum
output slope and the maximum authorized instantaneous current. If it was
bigger the output slope could be very tight and the current too big.

With the 0.35um process, an \fBx1\fP is able to drive about \fB125fF\fP,
\fBx2\fP -> \fB250fF\fP, \fBx4\fP -> \fB500fF\fP,\fBx8\fP -> \fB1000fF\fP.
This is just an indication since if a cell is overloaded, the only
consequence is to increase the propagation time. On the other hand, it is
not very good to under-load a cell because this leads to a signal overshoot.

With the 0.35um process, a \fB1\fP lambda interconnect wire is about
\fB0.15fF\fP, an average cell fan-in is 10fF. Then, if it needs about 50
lambdas to connect 2 cells, an \fBx1\fP cell is able to drive about 7
cells (125/(10+50*.15)=7). With 100 lambdas, 5 cells, with 750 lambdas
only 2 cells.

All this are indications.  Only a timing analysis on the extracted
transistor net-list from layout can tell if a cell is well used or not
(see tas(1) for informations about static timing analysis).

.SH BEHAVIOR

The user can deduce the cell behavior just by reading its name.  That is
very intuitive for \fBinv\fPerter and more complex for and/or cells.  For
the last, the name gives the and/or tree structure.  The input order for
the VHDL interface component is always the alphabetic order.

.nf
\fBinv\fP           : \fBinv\fPersor
\fBbuf\fP           : \fBbuf\fPfer
[\fBn\fP]\fBts\fP         : [\fBn\fPot] \fBt\fPree-\fBs\fPtate
[\fBn\fP]\fBxr\fP<i>      : [\fBn\fPot] \fBx\fPo\fBr\fP <i> inputs
[\fBn\fP]\fBmx\fP<i>      : [\fBn\fPot] \fBm\fPultiple\fBx\fPor <i> inputs with coded command
[\fBn\fP][\fBsd\fP]\fBff\fP<i>  : [\fBn\fPot] [\fBs\fPtatic|\fBd\fPynamic] \fBf\fPlip-\fBf\fPlop <i> inputs
[\fBn\fP]\fBoa\fP...      : [\fBn\fPot] \fBa\fPnd/\fBo\fPr function (see below)




\fBand_or cell (lex grammar):-\fP

NAME     : \fBn\fP OA_CELL                 -> not OA_CELL
         | OA_CELL                   -> OA_CELL

OA_CELL  : OPERATOR INPUTS           -> function with INPUTS inputs
         | OPERATOR OA_CELLS INPUTS  -> function with INPUTS inputs
                                        where some inputs are OA_CELL

OPERATOR : \fBa\fP                         -> and
         | \fBo\fP                         -> or

OA_CELLS : OA_CELLS OA_CELL          -> list of OA_CELL
         | OA_CELL                   -> last OA_CELL of the list

INPUTS   : \fBinteger\fP                   -> number of inputs

The input names are implicit and formed that way \fBi<number>\fP.
They are attributed in order beginning by \fBi0\fP.

\fBExamples:-\fP (some are not in sxlib)

na2       : not( and(i0,i1))
noa2a22   : not( or( and(i0,i1), and(i2,i3)))
noa23     : not( or( and(i0,i1), i3))
noao22a34 : not( or( and( or(i0,i1), i2), and(i3,i4,i5), i6, i7))

.fi

.SH CELL LIST

All available cells are listed below. The first column is the pitch width.
The pitch value is 5 lambdas. The height is 50. Area is then <number>*5*50.
The delay is in nano-seconds. Remember this delay corresponds to the slower
input+0.6ns. The behavior gives logic function. / means not, + means or, .
means and, ^ means xor. Each input is followed by fan-in capacitance in fF,
(e.g. i0<11> means i0 pin capacitance is 11fF).
.nf


\fB=================================================================\fP
\fBWIDTH NAME    DELAY BEHAVIOR\fP
\fB-------------------------------------------------------- INVERSOR\fP
 3 inv_x1      .7  nq <= /i<8>
 3 inv_x2      .7  nq <= /i<12>
 4 inv_x4      .7  nq <= /i<26>
 7 inv_x8      .7  nq <= /i<54>
\fB---------------------------------------------------------- BUFFER\fP
 4 buf_x2     1.0   q <=  i<6>
 5 buf_x4     1.0   q <=  i<9>
 8 buf_x8     1.0   q <=  i<15>

\fB------------------------------------------------------ THREE STATE\fP
 6 nts_x1      .8  IF (cmd<14>) nq <= /i<14>
 8 nts_x2      .9  IF (cmd<18>) nq <= /i<28>
10 ts_x4      1.1  IF (cmd<19>)  q <= i<8>
13 ts_x8      1.2  IF (cmd<19>)  q <= i<8>
\fB-------------------------------------------------------------- AND\fP
 4 na2_x1      .9  nq <= /(i0<11>.i1<11>)
 7 na2_x4     1.2  nq <= /(i0<10>.i1<10>)
 5 na3_x1     1.0  nq <= /(i0<11>.i1<11>.i2<11>)
 8 na3_x4     1.3  nq <= /(i0<10>.i1<10>.i2<10>)
 6 na4_x1     1.0  nq <= /(i0<10>.i1<11>.i2<11>.i3<11>)
10 na4_x4     1.4  nq <= /(i0<10>.i1<11>.i2<11>.i3<11>)
 5 a2_x2      1.0   q <=  (i0<9>.i1<11>)
 6 a2_x4      1.1   q <=  (i0<9>.i1<11>)
 6 a3_x2      1.1   q <=  (i0<10>.i1<10>.i2<10>)
 7 a3_x4      1.2   q <=  (i0<10>.i1<10>.i2<10>)
 7 a4_x2      1.2   q <=  (i0<10>.i1<10>.i2<10>.i3<10>)
 8 a4_x4      1.3   q <=  (i0<10>.i1<10>.i2<10>.i3<10>)
\fB--------------------------------------------------------------- OR\fP
 4 no2_x1      .9  nq <= /(i0<12>+i1<12>)
 8 no2_x4     1.2  nq <= /(i0<12>+i1<11>)
 5 no3_x1     1.0  nq <= /(i0<12>+i1<12>+i2<12>)
 8 no3_x4     1.3  nq <= /(i0<12>+i1<12>+i2<11>)
 6 no4_x1     1.1  nq <= /(i0<12>+i1<12>+i2<12>+i3<12>)
10 no4_x4     1.4  nq <= /(i0<12>+i1<12>+i2<12>+i3<12>)
 5 o2_x2      1.0   q <=  (i0<10>+i1<10>)
 6 o2_x4      1.1   q <=  (i0<10>+i1<10>)
 6 o3_x2      1.1   q <=  (i0<10>+i1<10>+i2<9>)
10 o3_x4      1.2   q <=  (i0<10>+i1<10>+i2<9>)
 7 o4_x2      1.2   q <=  (i0<10>+i1<10>+i2<10>+i3<9>)
 8 o4_x4      1.3   q <=  (i0<12>+i1<12>+i2<12>+i3<12>)
\fB--------------------------------------------------------- AND/OR 3\fP
 6 nao22_x1    .9  nq <= /((i0<14>+i1<14>).i2<14>)
10 nao22_x4   1.3  nq <= /((i0<8>+i1<8>).i2<9>)
 6 noa22_x1    .9  nq <= /((i0<14>.i1<14>)+i2<14>)
10 noa22_x4   1.3  nq <= /((i0<8>.i1<8>)+i2<9>)
 6 ao22_x1    1.2  nq <=  ((i0<8>+i1<8>).i2<9>)
 8 ao22_x4    1.3  nq <=  ((i0<8>+i1<8>).i2<9>)
 6 oa22_x1    1.2  nq <=  ((i0<8>.i1<8>)+i2<9>)
 8 oa22_x4    1.3  nq <=  ((i0<8>.i1<8>)+i2<9>)
\fB--------------------------------------------------------- AND/OR 4\fP
 7 nao2o22_x1 1.0  nq <= /((i0<14>+i1<14>).(i2<14>+i3<14>))
11 nao2o22_x4 1.4  nq <= /((i0<8>+i1<8>).(i2<8>+i3<8>))
 7 noa2a22_x1 1.0  nq <= /((i0<14>.i1<14>)+(i2<14>.i3<14>))
11 noa2a22_x4 1.4  nq <= /((i0<8>.i1<8>)+(i2<8>.i3<8>))
 9 ao2o22_x1  1.2  nq <=  ((i0<8>+i1<8>).(i2<8>+i3<8>))
10 ao2o22_x4  1.3  nq <=  ((i0<8>+i1<8>).(i2<8>+i3<8>))
 9 oa2a22_x1  1.2  nq <=  ((i0<8>.i1<8>)+(i2<8>.i3<8>))
10 oa2a22_x4  1.4  nq <=  ((i0<8>.i1<8>)+(i2<8>.i3<8>))



\fB------------------------------------------------------ MULTIPLEXER\fP
 7 nmx2_x1    1.0  nq <= /((i0<14>./cmd<21>)+(i1<14>.cmd))
12 nmx2_x4    1.3  nq <= /((i0<8>./cmd<14>)+(i1<9>.cmd))
 9 mx2_x2     1.1   q <=  (i0<8>./cmd<17>)+(i1<9>.cmd)
10 mx2_x4     1.3   q <=  (i0<8>./cmd<17>)+(i1<9>.cmd)
\fB-------------------------------------------------------------- XOR\fP
 9 nxr2_x1    1.1  nq <= /(i0<21>^i1<22>)
11 nxr2_x4    1.2  nq <= /(i0<20>^i1<21>)
 9 xr2_x1     1.0   q <=  (i0<21>^i1<22>)
12 xr2_x4     1.2   q <=  (i0<20>^i1<21>)
\fB-------------------------------------------------------- FLIP-FLOP\fP
."25 nsdff2_x4  1.0  IF RISE(ck<23>) nq <=/((i0<11>./cmd<13>)+(i1<7>.cmd))
18 sff1_x4    1.7  IF RISE(ck<8>)   q <= i<8>
24 sff2_x4    1.9  IF RISE(ck<8>)   q <= ((i0<8>./cmd<16>)+(i1<7>.cmd))
\fB---------------------------------------------------------- SPECIAL\fP
 3 zero_x0      0  nq <= '0'
 3 one_x0       0   q <= '1'
 2 tie_x0       0  Body tie cell
 1 rowend_x0    0  Empty cell
\fB==================================================================\fP
.fi

.SH NEW CELLS

It is possible to add new cells in the library just by providing the 3
files .ap, .al and .vbe in the standard cell directory.  The layout view
can be created with the symbolic editor graal.  The physical outline is
given above.  The net-list view can be automatically generated with the
lynx extractor.  The behavioral view must be written by the designer and
checked with the yagle functional abstractor.  The file must contain the
generic fields in order to be used by the logic synthesis tools and the
I/Os terminals must be in the same order (alphabetic) in the .vbe and .al
files.

If you develop new cells, please send the corresponding files
to alliance\-support@asim.lip6.fr

.SH VHDL FILES

You can find below the commented VHDL GENERIC for the na2_x4 cell.
.nf
ENTITY na2_x4 IS
GENERIC (
  CONSTANT area          : NATURAL := 1750; -- lamba * lambda
  CONSTANT transistors   : NATURAL := 10;   -- number of
  CONSTANT cin_i0        : NATURAL := 10;   -- femto Farad for i0
  CONSTANT cin_i1        : NATURAL := 10;   -- femto Farad for i1
  CONSTANT tplh_i1_nq    : NATURAL := 606;  -- propag. time in pico-sec
                                            -- from i1 falling
                                            -- to   nq rizing
  CONSTANT rup_i1_nq     : NATURAL := 890;  -- resitance in Ohms when nq
                                            -- rizing due to i1 change
  CONSTANT tphl_i1_nq    : NATURAL := 349;  -- propag time when nq falls
  CONSTANT rdown_i1_nq   : NATURAL := 800;  -- resist when nq falls
  CONSTANT tplh_i0_nq    : NATURAL := 557;  -- idem for i0
  CONSTANT rup_i0_nq     : NATURAL := 890;
  CONSTANT tphl_i0_nq    : NATURAL := 408;
  CONSTANT rdown_i0_nq   : NATURAL := 800
);
PORT (
  i0     : in  BIT;
  i1     : in  BIT;
  nq     : out BIT;
  vdd    : in  BIT;
  vss    : in  BIT
);
.fi

.SH SEE ALSO

\fBMBK_CATA_LIB (1), catal(1), scr(1), lynx(1), bop(1), glop(1), scmap(1),
c4map(1), tas(1), yagle(1), genlib(1), ap(1), al(1), vbe(1)\fP

.so man1/alc_bug_report.1
