.\"   $Id: sclib.5,v 1.1 1999/05/31 17:30:28 alliance Exp $
.\" @(#)Labo.l 0.0 92/09/24 UPMC; Author: El Housseine REJOUAN
.pl -.4
.TH SCLIB 5 "October 1, 1997" "ASIM/LIP6" "CAO\-VLSI Reference Manual"
.SH NAME
.TP
.B sclib
 - a portable CMOS Standard Cell Library
.so man1/alc_origin.1
.SH SYNOPSIS
.TP
The library directory is defined by the environment variable \fBMBK_CATA_LIB\fP.
.br
.SH DESCRIPTION

 The symbolic layout approach is used for cell layout in order to provide process independance. The mapping to a specific process CIF or GDS2 layout is performed by s2r tool.
.br
 Four files are attached to each cell :
.br
- layout			cellname.ap
.br
- transistor net-list	cellname.al
.br
- VHDL behaviour	cellname.vbe
.br
- postscript doc		cellname.ps
.br
For each cell, you can get detailed information using "man cellname".
.br
At the moment, sclib contains standard cells that have been developped at UPMC-ASIM/LIP6.
.br
It is possible to add new cells in the library just by providing the 3 files .ap, .al and .vbe in the standard cell directory.
.br
The layout view can be created with the symbolic editor graal.
.br
The topological constraints for the standard cell router scr are the abutment box size (height = 42 , width = 6 x n ), the metal1 VDD and VSS lines, the N well abutment, and I/Os in metal2 on south and north sides.
.br
The net-list view can be automatically generated with the lynx extractor
.br
The behavioural view can be checked with the yagle functional abstractor. The file must contain the generic fields in order to be used by the logic synthesis tools and the I/Os terminals must be in the same order in the .vbe and .al files.
.br
If you develop new cells, please send the corresponding files to alliance\-support@asim.lip6.fr

.B List of cells :
.br

-------------------------------------------------------------------------------------------------------
.br
|	Description				Fanout		Name            |
.br
-------------------------------------------------------------------------------------------------------
.br
	\fB=> AND\fP
.br
	  (A.B)					(drive=1)	a2_y                               
.br
	  (A.B)					(drive=2)	a2p_y
.br
	  (A.B.C)				(drive=1)	a3_y
.br
	  (A.B.C)				(drive=2)	a3p_y
.br
	  (A.B.C.D)				(drive=1)	a4_y
.br
	  (A.B.C.D)				(drive=2)	a4p_y
.br
	  /(A.B)					(drive=1)	na2_y
.br
	  /(A.B)					(drive=2)	na2p_y
.br
	  /(A.B.C)				(drive=1)	na3_y
.br
	  /(A.B.C)				(drive=2)	na3p_y
.br
	  /(A.B.C.D)				(drive=1)	na4_y
.br

	\fB=> OR\fP 
.br
	   (A+B)					(drive=1)	o2_y
.br
	   (A+B)					(drive=2)	op2_y
.br
	   (A+B+C)				(drive=1)	o3_y
.br
	   (A+B+C)				(drive=2)	op3_y
.br
	   /(A+B)				(drive=1)	no2_y
.br
	   /(A+B)				(drive=2)	nop2_y
.br
	   /(A+B+C)				(drive=1)	no3_y
.br
	   /(A+B+C)				(drive=2)	nop3_y
.br

	\fB=>INV/BUF/DELAY\fP
.br
	   inv					(drive=1)	n1_y
.br
	   inv					(drive=2)	np1_y
.br
	   inv					(drive=4)	ndrv_y
.br
	   buf					(drive=2)	p1_y
.br
	   buf					(drive=4)	b1_y
.br
	   delay					(drive=1)	d1_y
.br

	\fB=> T STATE\fP
.br
	   3-state-inv				(drive=1)	tsn_y
.br
	   3-state-buf				(drive=1)	ts_y
.br
	   3-state-buf				(drive=2)	tsp_y
.br

	\fB=> XOR\fP
.br
	   xor					(drive=1)	xr2_y
.br
	   nxor					(drive=1)	nxr2_y
.br

	\fB=> COMPLEX\fP
.br
	   /(AB+CD)				(drive=1)	nmx2_y
.br
	   /(A+B)(C+D)				(drive=1)	annup_y
.br
	   /((A+B)C)				(drive=1)	noa3_y
.br
	   /(AB+C)				(drive=1)	nao3_y
.br
	   /(ABC+D)				(drive=1)	nao4_y
.br
	   /(A.B.(C+D))				(drive=1)	noue4_y
.br
	   /(A.(B+C+D))				(drive=1)	noa4_y
.br

	\fB=> LATCH\fP
.br
	   latch one input (Q,QN)			(drive=1)	lx_y
.br
	   latch one input (Q)			(drive=2)	l1_y
.br
	   latch one input (QN)			(drive=1)	l1n_y
.br
	   latch two inputs (Q)			(drive=2)	l2_y
.br
	   latch two inputs (QN)			(drive=1)	l2n_y
.br
	   latch three inputs (Q)			(drive=1)	l3_y
.br
	   latch two inputs with reset (Q)		(drive=1)	l3r_y
.br
	   latch two inputs with set (Q)		(drive=1)	l3s_y
.br
	   latch four inputs (Q)			(drive=1)	l4_y
.br
	   latch three inputs with reset (Q)		(drive=1)	l4r_y
.br
	   latch three inputs with set (Q)		(drive=1)	l4s_y
.br
	   latch five inputs (Q)			(drive=1)	l5_y
.br
	   latch four inputs with reset (Q)		(drive=1)	l5r_y
.br
	   latch four inputs with set (Q)		(drive=1)	l5s_y
.br
	   latch five inputs with reset (Q)		(drive=1)	l6r_y
.br
	   latch five inputs with set (Q)		(drive=1)	l6s_y
.br

	\fB=>FF\fP
.br
	   master-slave (Q,QN)			(drive=1)	msx_y
.br
	   master-slave (Q)			(drive=1)	ms_y
.br
	   master-slave (QN)			(drive=1)	msn_y
.br
	   master-slave with set (Q,QN)		(drive=1)	mssx_y
.br
	   master-slave with reset (Q,QN)		(drive=1)	msrx_y
.br
	   scannable master-slave (Q)		(drive=1)	ms2_y
.br
	   scannable master-slave(QN)		(drive=1)	ms2n_y
.br
	   scannable master-slave (Q,QN)		(drive=1)	ms2x_y
.br
	   scannable master-slave with set (Q,QN)	(drive=1)	ms2sx_y
.br
	   scannable master-slave with reset (Q,QN)	(drive=1)	ms2rx_y
.br

	\fB=>BUS\fP
.br
	   bus hold (inverted)			(drive=1)	zbli_y
.br
	   pull-up						one_y
.br
	   pull-down						zero_y
.br
	   feed-through						tie_y
.br

	\fB=>MUX\fP
.br
	   mux 2 to 1 (two controls)		(drive=1)	mx2_y
.br
	   mux 2 to 1 (two controls)		(drive=2)	mx2p_y
.br
	   mux 2 to 1 (one control)			(drive=1)	cmx2_y
.br
	   mux 3 to 1 (three controls)		(drive=1)	mx3_y
.br
	   mux 4 to 1 (four controls)		(drive=1)	mx4_y
.br

	\fB=>SPECIAL\fP
.br
	   full-adder (sum)			(drive=1)	sum_y
.br
	   full-adder (carry)			(drive=1)	cry_y
.br
.SH SEE ALSO
.BR MBK_CATA_LIB (1),
.BR catal (1),
.BR scr (1),
.BR lynx (1),
.BR bop(1), 
.BR glop(1), 
.BR scmap(1), 
.BR c4map(1), 
.BR yagle (1),
.BR genlib (1),
.BR ap (1),
.BR al (1),
.BR vbe (1),

.so man1/alc_bug_report.1

